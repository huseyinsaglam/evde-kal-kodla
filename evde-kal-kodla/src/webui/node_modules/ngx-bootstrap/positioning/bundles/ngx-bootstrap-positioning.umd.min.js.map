{"version":3,"sources":["node_modules/tslib/tslib.es6.js","ng://ngx-bootstrap/positioning/utils/getStyleComputedProperty.ts","ng://ngx-bootstrap/positioning/utils/getParentNode.ts","ng://ngx-bootstrap/positioning/utils/getScrollParent.ts","ng://ngx-bootstrap/positioning/utils/isBrowser.ts","ng://ngx-bootstrap/positioning/utils/isIE.ts","ng://ngx-bootstrap/positioning/utils/getOffsetParent.ts","ng://ngx-bootstrap/positioning/utils/getRoot.ts","ng://ngx-bootstrap/positioning/utils/findCommonOffsetParent.ts","ng://ngx-bootstrap/positioning/utils/isOffsetContainer.ts","ng://ngx-bootstrap/positioning/utils/getBordersSize.ts","ng://ngx-bootstrap/positioning/utils/getWindowSizes.ts","ng://ngx-bootstrap/positioning/utils/getScroll.ts","ng://ngx-bootstrap/positioning/utils/getClientRect.ts","ng://ngx-bootstrap/positioning/utils/getBoundingClientRect.ts","ng://ngx-bootstrap/positioning/utils/getOffsetRectRelativeToArbitraryNode.ts","ng://ngx-bootstrap/positioning/utils/includeScroll.ts","ng://ngx-bootstrap/positioning/utils/getFixedPositionOffsetParent.ts","ng://ngx-bootstrap/positioning/utils/getBoundaries.ts","ng://ngx-bootstrap/positioning/utils/getViewportOffsetRectRelativeToArtbitraryNode.ts","ng://ngx-bootstrap/positioning/utils/isFixed.ts","ng://ngx-bootstrap/positioning/utils/computeAutoPlacement.ts","ng://ngx-bootstrap/positioning/utils/getOppositePlacement.ts","ng://ngx-bootstrap/positioning/utils/getOuterSizes.ts","ng://ngx-bootstrap/positioning/utils/getReferenceOffsets.ts","ng://ngx-bootstrap/positioning/utils/getTargetOffsets.ts","ng://ngx-bootstrap/positioning/utils/setAllStyles.ts","ng://ngx-bootstrap/positioning/utils/getOffsets.ts","ng://ngx-bootstrap/positioning/utils/setStyles.ts","ng://ngx-bootstrap/positioning/utils/isNumeric.ts","ng://ngx-bootstrap/positioning/modifiers/arrow.ts","ng://ngx-bootstrap/positioning/modifiers/flip.ts","ng://ngx-bootstrap/positioning/utils/getOppositeVariation.ts","ng://ngx-bootstrap/positioning/modifiers/preventOverflow.ts","ng://ngx-bootstrap/positioning/modifiers/shift.ts","ng://ngx-bootstrap/positioning/ng-positioning.ts","ng://ngx-bootstrap/positioning/modifiers/initData.ts","ng://ngx-bootstrap/positioning/positioning.service.ts"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","getStyleComputedProperty","element","property","nodeType","css","ownerDocument","defaultView","getComputedStyle","getParentNode","nodeName","parentNode","host","getScrollParent","document","body","_a","overflow","overflowX","overflowY","test","String","isBrowser","window","isIE11","MSInputMethodContext","documentMode","isIE10","navigator","userAgent","isIE","version","getOffsetParent","documentElement","sibling","noOffsetParent","offsetParent","nextElementSibling","indexOf","getRoot","node","findCommonOffsetParent","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","isOffsetContainer","firstElementChild","element1root","getBordersSize","styles","axis","sideA","sideB","parseFloat","getSize","html","computedStyle","Math","max","parseInt","getWindowSizes","height","width","getScroll","side","upperSide","scrollingElement","getClientRect","offsets","right","left","bottom","top","getBoundingClientRect","rect","scrollTop","scrollLeft","e","undefined","result","sizes","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getOffsetRectRelativeToArbitraryNode","children","parent","fixedPosition","runIsIE","isHTML","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","includeScroll","subtract","modifier","getFixedPositionOffsetParent","parentElement","el","getBoundaries","target","padding","boundariesElement","boundaries","getViewportOffsetRectRelativeToArtbitraryNode","excludeScroll","relativeOffset","innerWidth","innerHeight","Number","boundariesNode","isFixed","computeAutoPlacement","placement","refRect","split","rects","sortedAreas","keys","map","key","area","getArea","sort","a","b","filteredAreas","filter","computedPlacement","variation","className","replace","getOppositePlacement","hash","matched","getOuterSizes","x","marginBottom","y","marginRight","getReferenceOffsets","getTargetOffsets","hostOffsets","position","targetRect","targetOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","setAllStyles$$1","data","renderer","instance","getOffsets","floor","round","setStyles","will-change","transform","arrow","placementAuto","setAttribute","match","addClass","classList","add","forEach","prop","unit","isNumeric","isNaN","isFinite","setStyle","style","arrowElement","querySelector","isVertical","len","sideCapitalized","toLowerCase","altSide","opSide","arrowElementSize","center","targetMarginSide","targetBorderSide","sideValue","min","flip","adaptivePosition","flipOrder","step","index","overlapsRef","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariation","getOppositeVariation","preventOverflow","transformProp","targetStyles","check","primary","value","secondary","shift","basePlacement","shiftvariation","shiftOffsets","_b","_c","Positioning","hostElement","targetElement","offset","positionElements","appendToBody","reduce","modifiedData","initData","hostElPosition","positionFixed","positionService","setAllStyles","PositioningService","rendererFactory","_this","Subject","merge","fromEvent","of","animationFrameScheduler","update$$","Map","events$","subscribe","positionElement","_getHtmlElement","attachment","createRenderer","options","addPositionElement","next","set","deletePositionElement","elRef","delete","Injectable","RendererFactory2","ElementRef","nativeElement"],"mappings":"4WA6BO,IAAIA,EAAW,WAQlB,OAPAA,EAAWC,OAAOC,QAAU,SAAkBC,GAC1C,IAAK,IAAIC,EAAGC,EAAI,EAAGC,EAAIC,UAAUC,OAAQH,EAAIC,EAAGD,IAE5C,IAAK,IAAII,KADTL,EAAIG,UAAUF,GACOJ,OAAOS,UAAUC,eAAeC,KAAKR,EAAGK,KAAIN,EAAEM,GAAKL,EAAEK,IAE9E,OAAON,IAEKU,MAAMC,KAAMP,YClChC,SAAAQ,EAAyCC,EAAsBC,GAC7D,GAAyB,IAArBD,EAAQE,SACV,MAAO,GAGT,IACMC,EADSH,EAAQI,cAAcC,YAClBC,iBAAiBN,EAAS,MAE7C,OAAOC,EAAWE,EAAIF,GAAYE,ECRpC,SAAAI,EAA8BP,GAC5B,MAAyB,SAArBA,EAAQQ,SACHR,EAGFA,EAAQS,YAAcT,EAAQU,KCFvC,SAAAC,EAAgCX,GAE9B,IAAKA,EACH,OAAOY,SAASC,KAGlB,OAAQb,EAAQQ,UACd,IAAK,OACL,IAAK,OACH,OAAOR,EAAQI,cAAcS,KAC/B,IAAK,YACH,OAAOb,EAAQa,KAKnB,IAAAC,EAAAf,EAAAC,GAAQe,EAAAD,EAAAC,SAAUC,EAAAF,EAAAE,UAAWC,EAAAH,EAAAG,UAC7B,MAAI,wBAAwBC,KAAKC,OAAOJ,GAAYI,OAAOF,GAAaE,OAAOH,IACtEhB,EAGFW,EAAgBJ,EAAcP,IC3BhC,IAAMoB,EAA8B,oBAAXC,QAA8C,oBAAbT,SCK3DU,EAASF,MAAgB,OAAgBG,uBAAwB,SAAkBC,cACnFC,EAASL,GAAa,UAAUF,KAAKQ,UAAUC,WAErD,SAAAC,EAAqBC,GACnB,OAAgB,KAAZA,EACKP,EAEO,KAAZO,EACKJ,EAGFH,GAAUG,ECVnB,SAAAK,EAAgC9B,GAC9B,IAAKA,EACH,OAAOY,SAASmB,gBAWlB,IARA,IAMIC,EANEC,EAAiBL,EAAK,IAAMhB,SAASC,KAAO,KAG9CqB,EAAelC,EAAQkC,cAAgB,KAKpCA,IAAiBD,GAAkBjC,EAAQmC,oBAEhDD,GADAF,EAAUhC,EAAQmC,oBACKD,aAGzB,IAAM1B,EAAW0B,GAAgBA,EAAa1B,SAE9C,OAAKA,GAAyB,SAAbA,GAAoC,SAAbA,GAOoB,IAA1D,CAAC,KAAM,KAAM,SAAS4B,QAAQF,EAAa1B,WACY,WAAvDT,EAAyBmC,EAAc,YAEhCJ,EAAgBI,GAGlBA,EAZEF,EAAUA,EAAQ5B,cAAc2B,gBAAkBnB,SAASmB,gBCxBtE,SAAAM,EAAwBC,GACtB,OAAwB,OAApBA,EAAK7B,WACA4B,EAAQC,EAAK7B,YAGf6B,ECDT,SAAAC,EAAuCC,EAAuBC,GAE5D,KAAKD,GAAaA,EAAStC,UAAauC,GAAaA,EAASvC,UAC5D,OAAOU,SAASmB,gBAKlB,IAAMW,EAAQF,EAASG,wBAAwBF,GAAYG,KAAKC,4BAE1DC,EAAQJ,EAAQF,EAAWC,EAC3BM,EAAML,EAAQD,EAAWD,EAGzBQ,EAAQpC,SAASqC,cACvBD,EAAME,SAASJ,EAAO,GACtBE,EAAMG,OAAOJ,EAAK,GACV,IAAAK,EAAAJ,EAAAI,wBAGR,GACGZ,IAAaY,GACZX,IAAaW,GACfN,EAAMO,SAASN,GAEf,OC9BJ,SAAAO,EAAkCtD,GACxB,IAAAQ,EAAAR,EAAAQ,SACR,MAAiB,SAAbA,IAKW,SAAbA,GAAuBsB,EAAgB9B,EAAQuD,qBAAuBvD,GDuBlEsD,CAAkBF,GACbA,EAGFtB,EAAgBsB,GAIzB,IAAMI,EAAenB,EAAQG,GAC7B,OAAIgB,EAAa9C,KACR6B,EAAuBiB,EAAa9C,KAAM+B,GAE1CF,EAAuBC,EAAUH,EAAQI,GAAU/B,MExC9D,SAAA+C,EAA+BC,EAA6BC,GAC1D,IAAMC,EAAiB,MAATD,EAAe,OAAS,MAChCE,EAAkB,SAAVD,EAAmB,QAAU,SAE3C,OACEE,WAAWJ,EAAO,SAASE,EAAK,UAChCE,WAAWJ,EAAO,SAASG,EAAK,UCRpC,SAAAE,EAAiBJ,EAAc9C,EAAmBmD,EAAmBC,GACnE,OAAOC,KAAKC,IACVtD,EAAK,SAAS8C,GACd9C,EAAK,SAAS8C,GACdK,EAAK,SAASL,GACdK,EAAK,SAASL,GACdK,EAAK,SAASL,GACd/B,EAAK,IACAwC,SAASJ,EAAK,SAASL,GAAS,IACnCS,SAASH,EAAc,UAAkB,WAATN,EAAoB,MAAQ,SAAW,IACvES,SAASH,EAAc,UAAkB,WAATN,EAAoB,SAAW,UAAY,IAC3E,GAIN,SAAAU,EAA+BzD,GAC7B,IAAMC,EAAOD,EAASC,KAChBmD,EAAOpD,EAASmB,gBAChBkC,EAAgBrC,EAAK,KAAOtB,iBAAiB0D,GAEnD,MAAO,CACLM,OAAQP,EAAQ,SAAUlD,EAAMmD,EAAMC,GACtCM,MAAOR,EAAQ,QAASlD,EAAMmD,EAAMC,ICrBxC,SAAAO,EAA0BxE,EAAsByE,QAAA,IAAAA,IAAAA,EAAA,OAC9C,IAAMC,EAAqB,QAATD,EAAiB,YAAc,aAC3CjE,EAAWR,EAAQQ,SAEzB,GAAiB,SAAbA,GAAoC,SAAbA,EAO3B,OAAOR,EAAQ0E,GANb,IAAMV,EAAOhE,EAAQI,cAAc2B,gBAGnC,OAFyB/B,EAAQI,cAAcuE,kBAAoBX,GAE3CU,GCN5B,SAAAE,EAA8BC,GAC5B,OAAA7F,EAAA,GACK6F,EAAO,CACVC,MAAOD,EAAQE,KAAOF,EAAQN,MAC9BS,OAAQH,EAAQI,IAAMJ,EAAQP,SCElC,SAAAY,EAAsClF,GACpC,IAAImF,EAAY,GAKhB,IACE,GAAIvD,EAAK,IAAK,CACZuD,EAAOnF,EAAQkF,wBACf,IAAME,EAAYZ,EAAUxE,EAAS,OAC/BqF,EAAab,EAAUxE,EAAS,QACtCmF,EAAKF,KAAOG,EACZD,EAAKJ,MAAQM,EACbF,EAAKH,QAAUI,EACfD,EAAKL,OAASO,OAEdF,EAAOnF,EAAQkF,wBAEjB,MAAOI,GACP,OAAOC,UAGT,IAAMC,EAAc,CAClBT,KAAMI,EAAKJ,KACXE,IAAKE,EAAKF,IACVV,MAAOY,EAAKL,MAAQK,EAAKJ,KACzBT,OAAQa,EAAKH,OAASG,EAAKF,KAIvBQ,EAAkC,SAArBzF,EAAQQ,SAAsB6D,EAAerE,EAAQI,eAAiB,GACnFmE,EACJkB,EAAMlB,OAASvE,EAAQ0F,aAAeF,EAAOV,MAAQU,EAAOT,KACxDT,EACJmB,EAAMnB,QAAUtE,EAAQ2F,cAAgBH,EAAOR,OAASQ,EAAOP,IAE7DW,EAAiB5F,EAAQ6F,YAActB,EACvCuB,EAAgB9F,EAAQ+F,aAAezB,EAI3C,GAAIsB,GAAkBE,EAAe,CACnC,IAAMpC,EAAS3D,EAAyBC,GACxC4F,GAAkBnC,EAAeC,EAAQ,KACzCoC,GAAiBrC,EAAeC,EAAQ,KAExC8B,EAAOjB,OAASqB,EAChBJ,EAAOlB,QAAUwB,EAGnB,OAAOlB,EAAcY,GCrDvB,SAAAQ,EACEC,EACAC,EACAC,QAAA,IAAAA,IAAAA,GAAA,GAEA,IAAM1E,EAAS2E,EAAQ,IACjBC,EAA6B,SAApBH,EAAO1F,SAChB8F,EAAoBpB,EAAsBe,GAC1CM,EAAkBrB,EAAsBgB,GACxCM,EAAe7F,EAAgBsF,GAE/BvC,EAAS3D,EAAyBmG,GAClCO,EAAiB3C,WAAWJ,EAAO+C,gBACnCC,EAAkB5C,WAAWJ,EAAOgD,iBAGtCP,GAAiBE,IACnBE,EAAWtB,IAAMf,KAAKC,IAAIoC,EAAWtB,IAAK,GAC1CsB,EAAWxB,KAAOb,KAAKC,IAAIoC,EAAWxB,KAAM,IAG9C,IAAIF,EAAmBD,EAAc,CACnCK,IAAKqB,EAAarB,IAAMsB,EAAWtB,IAAMwB,EACzC1B,KAAMuB,EAAavB,KAAOwB,EAAWxB,KAAO2B,EAC5CnC,MAAO+B,EAAa/B,MACpBD,OAAQgC,EAAahC,SAUvB,GAPAO,EAAQ8B,UAAY,EACpB9B,EAAQ+B,WAAa,GAMhBnF,GAAU4E,EAAQ,CACrB,IAAMM,EAAY7C,WAAWJ,EAAOiD,WAC9BC,EAAa9C,WAAWJ,EAAOkD,YAErC/B,EAAQI,KAAOwB,EAAiBE,EAChC9B,EAAQG,QAAUyB,EAAiBE,EACnC9B,EAAQE,MAAQ2B,EAAkBE,EAClC/B,EAAQC,OAAS4B,EAAkBE,EAGnC/B,EAAQ8B,UAAYA,EACpB9B,EAAQ+B,WAAaA,EAWvB,OAPEnF,IAAW0E,EACPD,EAAO7C,SAASmD,GAChBN,IAAWM,GAA0C,SAA1BA,EAAahG,YAE5CqE,ECxDJ,SAAAgC,EAA8B1B,EAAenF,EAAsB8G,QAAA,IAAAA,IAAAA,GAAA,GACjE,IAAM1B,EAAYZ,EAAUxE,EAAS,OAC/BqF,EAAab,EAAUxE,EAAS,QAChC+G,EAAWD,GAAY,EAAI,EAMjC,OALA3B,EAAKF,KAAOG,EAAY2B,EACxB5B,EAAKH,QAAUI,EAAY2B,EAC3B5B,EAAKJ,MAAQM,EAAa0B,EAC1B5B,EAAKL,OAASO,EAAa0B,EAEpB5B,ED+CK0B,CAAchC,EAASqB,IAG5BrB,EE1DT,SAAAmC,EAA6ChH,GAE3C,IAAKA,IAAYA,EAAQiH,eAAiBrF,IACzC,OAAOhB,SAASmB,gBAKjB,IAFA,IAAImF,EAAKlH,EAAQiH,cAEVC,GAAoD,SAA9CnH,EAAyBmH,EAAI,cACxCA,EAAKA,EAAGD,cAGV,OAAOC,GAAMtG,SAASmB,gBCPxB,SAAAoF,EACEC,EACA1G,EACA2G,EACAC,EACAnB,QAFA,IAAAkB,IAAAA,EAAA,QAEA,IAAAlB,IAAAA,GAAA,GAIA,IAAIoB,EAAkB,CAAEtC,IAAK,EAAGF,KAAM,GAChC7C,EAAeiE,EAAgBa,EAA6BI,GAAU7E,EAAuB6E,EAAQ1G,GAG3G,GAA0B,aAAtB4G,EACFC,ECrBJ,SAAAC,EAA8DxH,EAAsByH,QAAA,IAAAA,IAAAA,GAAA,GAClF,IAAMzD,EAAOhE,EAAQI,cAAc2B,gBAC7B2F,EAAiB1B,EAAqChG,EAASgE,GAC/DO,EAAQL,KAAKC,IAAIH,EAAK0B,YAAarE,OAAOsG,YAAc,GACxDrD,EAASJ,KAAKC,IAAIH,EAAK2B,aAActE,OAAOuG,aAAe,GAE3DxC,EAAaqC,EAAkC,EAAlBjD,EAAUR,GACvCqB,EAAcoC,EAA0C,EAA1BjD,EAAUR,EAAM,QASpD,OAAOY,EAPQ,CACbK,IAAKG,EAAYyC,OAAOH,EAAezC,KAAO4C,OAAOH,EAAef,WACpE5B,KAAMM,EAAawC,OAAOH,EAAe3C,MAAQ8C,OAAOH,EAAed,YACvErC,MAAKA,EACLD,OAAMA,IDQOkD,CAA8CtF,EAAciE,OACpE,CAEL,IAAI2B,OAAc,EACQ,iBAAtBR,EAE8B,UADhCQ,EAAiBnH,EAAgBJ,EAAcG,KAC5BF,WACjBsH,EAAiBV,EAAOhH,cAAc2B,iBAGxC+F,EAD+B,WAAtBR,EACQF,EAAOhH,cAAc2B,gBAErBuF,EAGnB,IAAMzC,EAAUmB,EACd8B,EACA5F,EACAiE,GAIF,GAAgC,SAA5B2B,EAAetH,UE1CvB,SAAAuH,EAAwB/H,GACtB,IAAMQ,EAAWR,EAAQQ,SACzB,MAAiB,SAAbA,GAAoC,SAAbA,IAG2B,UAAlDT,EAAyBC,EAAS,aAI/B+H,EAAQxH,EAAcP,KFiCgB+H,CAAQ7F,GAQjDqF,EAAa1C,MARmD,CAChE,IAAA/D,EAAAuD,EAAA+C,EAAAhH,eAAQkE,EAAAxD,EAAAwD,OAAQC,EAAAzD,EAAAyD,MAChBgD,EAAWtC,KAAOJ,EAAQI,IAAMJ,EAAQ8B,UACxCY,EAAWvC,OAAS6C,OAAOvD,GAAUuD,OAAOhD,EAAQI,KACpDsC,EAAWxC,MAAQF,EAAQE,KAAOF,EAAQ+B,WAC1CW,EAAWzC,MAAQ+C,OAAOtD,GAASsD,OAAOhD,EAAQE,OAatD,OALAwC,EAAWxC,MAAQsC,EACnBE,EAAWtC,KAAOoC,EAClBE,EAAWzC,OAASuC,EACpBE,EAAWvC,QAAUqC,EAEdE,EGvDT,SAAAS,EACEC,EACAC,EACAd,EACA1G,EACA4G,EACAD,GAEA,QAFA,IAAAA,IAAAA,EAAA,IAEmC,IAA/BY,EAAU7F,QAAQ,QACpB,OAAO6F,EAGT,IAAmC,IAA/BA,EAAU7F,QAAQ,WACe,IAA/B6F,EAAU7F,QAAQ,UACa,IAAhC6F,EAAU7F,QAAQ,WACY,IAA9B6F,EAAU7F,QAAQ,SACe,IAAjC6F,EAAU7F,QAAQ,WAErB,OAAO6F,EAAUE,MAAM,KAAK,IAAM,GAGpC,IAAMZ,EAAaJ,EAAcC,EAAQ1G,EAAM2G,EAASC,GAElDc,EAAa,CACjBnD,IAAK,CACHV,MAAOgD,EAAWhD,MAClBD,OAAQ4D,EAAQjD,IAAMsC,EAAWtC,KAEnCH,MAAO,CACLP,MAAOgD,EAAWzC,MAAQoD,EAAQpD,MAClCR,OAAQiD,EAAWjD,QAErBU,OAAQ,CACNT,MAAOgD,EAAWhD,MAClBD,OAAQiD,EAAWvC,OAASkD,EAAQlD,QAEtCD,KAAM,CACJR,MAAO2D,EAAQnD,KAAOwC,EAAWxC,KACjCT,OAAQiD,EAAWjD,SAIjB+D,EAAcpJ,OAAOqJ,KAAKF,GAC7BG,IAAI,SAAAC,GAAO,OAAAxJ,EAAA,CACVwJ,IAAGA,GACAJ,EAAMI,GAAI,CACbC,KAlDN,SAAAC,EAAiB5H,GACf,OADiBA,EAAAyD,MAAOzD,EAAAwD,OAkDdoE,CAAQN,EAAMI,QAErBG,KAAK,SAACC,EAAGC,GAAM,OAAAA,EAAEJ,KAAOG,EAAEH,OAEvBK,EAAgBT,EAAYU,OAChC,SAACjI,OAAEyD,EAAAzD,EAAAyD,MAAOD,EAAAxD,EAAAwD,OACR,OAAAC,GAAS6C,EAAO1B,aAAepB,GAAU8C,EAAOzB,eAG9CqD,EAAmD,EAAvBF,EAActJ,OAC5CsJ,EAAc,GAAGN,IACjBH,EAAY,GAAGG,IAEbS,EAAYhB,EAAUE,MAAM,KAAK,GAIvC,OAFAf,EAAO8B,UAAY9B,EAAO8B,UAAUC,QAAQ,QAASH,GAE9CA,GAAqBC,EAAY,IAAIA,EAAc,ICvE5D,SAAAG,EAAqCnB,GACnC,IAAMoB,EAAO,CAAEtE,KAAM,QAASD,MAAO,OAAQE,OAAQ,MAAOC,IAAK,UAEjE,OAAOgD,EAAUkB,QAAQ,yBAA0B,SAAAG,GAAW,OAAAD,EAAKC,KCHrE,SAAAC,EAA8BvJ,GAC5B,IACM0D,EADS1D,EAAQI,cAAcC,YACfC,iBAAiBN,GACjCwJ,EAAI1F,WAAWJ,EAAOiD,WAAa,GAAK7C,WAAWJ,EAAO+F,cAAgB,GAC1EC,EAAI5F,WAAWJ,EAAOkD,YAAc,GAAK9C,WAAWJ,EAAOiG,aAAe,GAEhF,MAAO,CACLpF,MAAOsD,OAAO7H,EAAQ6F,aAAe6D,EACrCpF,OAAQuD,OAAO7H,EAAQ+F,cAAgByD,GCH3C,SAAAI,EACExC,EACA1G,EACAyF,GAMA,YANA,IAAAA,IAAAA,EAAA,MAMOH,EAAqCtF,EAJjByF,EACvBa,EAA6BI,GAC7B7E,EAAuB6E,EAAQ1G,GAEmCyF,GCVxE,SAAA0D,EACEzC,EACA0C,EACAC,GAEA,IAAM9B,EAAY8B,EAAS5B,MAAM,KAAK,GAGhC6B,EAAaT,EAAcnC,GAG3B6C,EAAgB,CACpB1F,MAAOyF,EAAWzF,MAClBD,OAAQ0F,EAAW1F,QAIf4F,GAAoD,IAA1C,CAAC,QAAS,QAAQ9H,QAAQ6F,GACpCkC,EAAWD,EAAU,MAAQ,OAC7BE,EAAgBF,EAAU,OAAS,MACnCG,EAAcH,EAAU,SAAW,QACnCI,EAAwBJ,EAAqB,QAAX,SAWxC,OATAD,EAAcE,GACZL,EAAYK,GACZL,EAAYO,GAAe,EAC3BL,EAAWK,GAAe,EAE5BJ,EAAcG,GAAiBnC,IAAcmC,EACzCN,EAAYM,GAAiBJ,EAAWM,GACxCR,EAAYV,EAAqBgB,IAE9BH,EC/BT,SAAAM,EAA6BC,EAAYC,GACvC,IAAMrD,EAASoD,EAAKE,SAAStD,OAEvBvC,ECTR,SAAA8F,EAA2BH,GACzB,MAAO,CACLjG,MAAOiG,EAAK3F,QAAQuC,OAAO7C,MAC3BD,OAAQkG,EAAK3F,QAAQuC,OAAO9C,OAC5BS,KAAMb,KAAK0G,MAAMJ,EAAK3F,QAAQuC,OAAOrC,MACrCE,IAAKf,KAAK2G,MAAML,EAAK3F,QAAQuC,OAAOnC,KACpCD,OAAQd,KAAK2G,MAAML,EAAK3F,QAAQuC,OAAOpC,QACvCF,MAAOZ,KAAK0G,MAAMJ,EAAK3F,QAAQuC,OAAOtC,QDExB6F,CAAWH,GAE3BM,EAAU1D,EAAQ,CAChB2D,cAAe,YACf9F,IAAK,MACLF,KAAM,MACNiG,UAAW,eAAenG,EAAQE,KAAI,OAAOF,EAAQI,IAAG,YACvDwF,GAECD,EAAKE,SAASO,OAChBH,EAAUN,EAAKE,SAASO,MAAOT,EAAK3F,QAAQoG,MAAOR,GAGjDD,EAAKU,gBACHT,GACFA,EAASU,aAAa/D,EAAQ,QAC5BA,EAAO8B,UAAUC,QAAQ,mBAAoB,cAAcqB,EAAKvC,YAElEwC,EAASU,aAAa/D,EAAQ,QAC5BA,EAAO8B,UAAUC,QAAQ,mBAAoB,cAAcqB,EAAKvC,YAGlEwC,EAASU,aAAa/D,EAAQ,QAC5BA,EAAO8B,UAAUC,QAAQ,UAAW,IAAKqB,EAAKvC,YAG5Cb,EAAO8B,UAAUkC,MAAM,aACzBX,EAASY,SAASjE,EAAQ,gBAGxBA,EAAO8B,UAAUkC,MAAM,aACzBX,EAASY,SAASjE,EAAQ,kBAK5BA,EAAO8B,UAAY9B,EAAO8B,UAAUC,QAAQ,mBAAoB,cAAcqB,EAAKvC,WACnFb,EAAO8B,UAAY9B,EAAO8B,UAAUC,QAAQ,mBAAoB,cAAcqB,EAAKvC,WACnFb,EAAO8B,UAAY9B,EAAO8B,UAAUC,QAAQ,UAAW,IAAKqB,EAAKvC,WAE7Db,EAAO8B,UAAUkC,MAAM,aACzBhE,EAAOkE,UAAUC,IAAI,gBAGnBnE,EAAO8B,UAAUkC,MAAM,aACzBhE,EAAOkE,UAAUC,IAAI,kBAKvBd,EACFA,EAASU,aAAa/D,EAAQ,QAASA,EAAO8B,UAAUC,QAAQ,yBAA0B,GAAGqB,EAAKvC,YAElGb,EAAO8B,UAAY9B,EAAO8B,UAAUC,QAAQ,yBAA0B,GAAGqB,EAAKvC,WEzDlF,SAAA6C,EAA0B9K,EAAsB0D,EAAa+G,GAC3DxL,OAAOqJ,KAAK5E,GAAQ8H,QAAQ,SAACC,GAC3B,IAAIC,EAAO,IAEkE,IAAzE,CAAC,QAAS,SAAU,MAAO,QAAS,SAAU,QAAQtJ,QAAQqJ,ICRtE,SAAAE,EAA0BrM,GACxB,MAAa,KAANA,IAAasM,MAAM9H,WAAWxE,KAAOuM,SAASvM,GDQjDqM,CAAUjI,EAAO+H,MACjBC,EAAO,MAGLjB,EACFA,EAASqB,SAAS9L,EAASyL,EAAM,GAAGtK,OAAOuC,EAAO+H,IAASC,GAK7D1L,EAAQ+L,MAAMN,GAAQtK,OAAOuC,EAAO+H,IAASC,IEnBjD,SAAAT,EAAsBT,GACpB,IAAIP,EAAgBO,EAAK3F,QAAQuC,OAE3B4E,EAAmCxB,EAAKE,SAAStD,OAAO6E,cAAc,UAG5E,IAAKD,EACH,OAAOxB,EAGT,IAAM0B,GAA4D,IAA/C,CAAC,OAAQ,SAAS9J,QAAQoI,EAAKvC,WAE5CkE,EAAMD,EAAa,SAAW,QAC9BE,EAAkBF,EAAa,MAAQ,OACvCzH,EAAO2H,EAAgBC,cACvBC,EAAUJ,EAAa,OAAS,MAChCK,EAASL,EAAa,SAAW,QACjCM,EAAmBjD,EAAcyC,GAAcG,GAGjD3B,EAAK3F,QAAQnE,KAAK6L,GAAUC,EAAmBvC,EAAcxF,KAC/DwF,EAAcxF,IACZwF,EAAcxF,IAAS+F,EAAK3F,QAAQnE,KAAK6L,GAAUC,IAGnD3E,OAAO2C,EAAK3F,QAAQnE,KAAK+D,IAASoD,OAAO2E,GAAoBvC,EAAcsC,KAC7EtC,EAAcxF,IACZoD,OAAO2C,EAAK3F,QAAQnE,KAAK+D,IAASoD,OAAO2E,GAAoB3E,OAAOoC,EAAcsC,KAEtFtC,EAAgBrF,EAAcqF,GAG9B,MAAMwC,EAAS5E,OAAO2C,EAAK3F,QAAQnE,KAAK+D,IAASoD,OAAO2C,EAAK3F,QAAQnE,KAAKyL,GAAO,EAAIK,EAAmB,GAIlGrM,EAAMJ,EAAyByK,EAAKE,SAAStD,QAE7CsF,EAAmB5I,WAAW3D,EAAI,SAASiM,IAC3CO,EAAmB7I,WAAW3D,EAAI,SAASiM,EAAe,UAC5DQ,EACFH,EAASxC,EAAcxF,GAAQiI,EAAmBC,EAYpD,OATAC,EAAY1I,KAAKC,IAAID,KAAK2I,IAAI5C,EAAckC,GAAOK,EAAkBI,GAAY,GAEjFpC,EAAK3F,QAAQoG,QAAKnK,EAAA,IACf2D,GAAOP,KAAK2G,MAAM+B,GACnB9L,EAACwL,GAAU,MAGb9B,EAAKE,SAASO,MAAQe,EAEfxB,EC9CT,SAAAsC,EAAqBtC,GACnBA,EAAK3F,QAAQuC,OAASxC,EAAc4F,EAAK3F,QAAQuC,QAEjD,IAAMG,EAAaJ,EACjBqD,EAAKE,SAAStD,OACdoD,EAAKE,SAAShK,KACd,EACA,YACA,GAGEuH,EAAYuC,EAAKvC,UAAUE,MAAM,KAAK,GACtCc,EAAYuB,EAAKvC,UAAUE,MAAM,KAAK,IAAM,GAE1C4E,EAAmB9D,EACrBG,EAAqBnB,GACrBD,EAAqB,OAAQwC,EAAK3F,QAAQnE,KAAM8J,EAAKE,SAAStD,OAAQoD,EAAKE,SAAShK,KAAM,WAAY,GAEpGsM,EAAY,CAAC/E,EAAW8E,GA+D9B,OA5DAC,EAAUxB,QAAQ,SAACyB,EAAMC,GACvB,GAAIjF,IAAcgF,GAAQD,EAAUxN,SAAW0N,EAAQ,EACrD,OAAO1C,EAMT,IAAM2C,EACW,UAJjBlF,EAAYuC,EAAKvC,UAAUE,MAAM,KAAK,KAKlCjE,KAAK0G,MAAMJ,EAAK3F,QAAQuC,OAAOtC,OAASZ,KAAK0G,MAAMJ,EAAK3F,QAAQnE,KAAKqE,OACxD,UAAdkD,GACC/D,KAAK0G,MAAMJ,EAAK3F,QAAQuC,OAAOrC,MAAQb,KAAK0G,MAAMJ,EAAK3F,QAAQnE,KAAKoE,QACvD,QAAdmD,GACC/D,KAAK0G,MAAMJ,EAAK3F,QAAQuC,OAAOpC,QAAUd,KAAK0G,MAAMJ,EAAK3F,QAAQnE,KAAKuE,MACzD,WAAdgD,GACC/D,KAAK0G,MAAMJ,EAAK3F,QAAQuC,OAAOnC,KAAOf,KAAK0G,MAAMJ,EAAK3F,QAAQnE,KAAKsE,QAEjEoI,EAAgBlJ,KAAK0G,MAAMJ,EAAK3F,QAAQuC,OAAOrC,MAAQb,KAAK0G,MAAMrD,EAAWxC,MAC7EsI,EAAiBnJ,KAAK0G,MAAMJ,EAAK3F,QAAQuC,OAAOtC,OAASZ,KAAK0G,MAAMrD,EAAWzC,OAC/EwI,EAAepJ,KAAK0G,MAAMJ,EAAK3F,QAAQuC,OAAOnC,KAAOf,KAAK0G,MAAMrD,EAAWtC,KAC3EsI,EAAkBrJ,KAAK0G,MAAMJ,EAAK3F,QAAQuC,OAAOpC,QAAUd,KAAK0G,MAAMrD,EAAWvC,QAEjFwI,EACW,SAAdvF,GAAwBmF,GACV,UAAdnF,GAAyBoF,GACX,QAAdpF,GAAuBqF,GACT,WAAdrF,GAA0BsF,EAGvBrB,GAAuD,IAA1C,CAAC,MAAO,UAAU9J,QAAQ6F,GACvCwF,EACFvB,GAA4B,SAAdjD,GAAwBmE,GACrClB,GAA4B,UAAdjD,GAAyBoE,IACtCnB,GAA4B,SAAdjD,GAAwBqE,IACtCpB,GAA4B,UAAdjD,GAAyBsE,GAEzCJ,GAAeK,GAAuBC,MAEpCN,GAAeK,KACjBvF,EAAY+E,EAAUE,EAAQ,IAG5BO,IACFxE,ECxER,SAAAyE,EAAqCzE,GACnC,MAAkB,UAAdA,EACK,OACgB,SAAdA,EACF,QAGFA,EDiEWyE,CAAqBzE,IAGnCuB,EAAKvC,UAAYA,GAAagB,EAAY,IAAIA,EAAc,IAE5DuB,EAAK3F,QAAQuC,OAAMpI,EAAA,GACdwL,EAAK3F,QAAQuC,OACbyC,EACDW,EAAKE,SAAStD,OACdoD,EAAK3F,QAAQnE,KACb8J,EAAKvC,eAMNuC,EExFT,SAAAmD,EAAgCnD,GAK9B,IAAMoD,EAAgB,YAChBC,EAAerD,EAAKE,SAAStD,OAAO2E,MAClC9G,EAAA4I,EAAA5I,IAAKF,EAAA8I,EAAA9I,KAAMiG,EAAA6C,EAAA,UACnBA,EAAa5I,IAAM,GACnB4I,EAAa9I,KAAO,GACpB8I,EAAaD,GAAiB,GAE9B,IAAMrG,EAAaJ,EACjBqD,EAAKE,SAAStD,OACdoD,EAAKE,SAAShK,KACd,EACA,gBACA,GAKFmN,EAAa5I,IAAMA,EACnB4I,EAAa9I,KAAOA,EACpB8I,EAAaD,GAAiB5C,EAE9B,IAgCIvG,EA9BEqJ,EAAQ,CACZC,iBAAQ9F,GACN,MAAI+F,EAAQxD,EAAK3F,QAAQuC,OAAOa,GAQhC,OANEuC,EAAK3F,QAAQuC,OAAOa,GAAaV,EAAWU,KAG5C+F,EAAQ9J,KAAKC,IAAIqG,EAAK3F,QAAQuC,OAAOa,GAAYV,EAAWU,MAG9DnH,EAAA,IAAUmH,GAAY+F,EAAKlN,GAE7BmN,mBAAUhG,GACR,MAAMkC,EAAyB,UAAdlC,EAAwB,OAAS,MAC9C+F,EAAQxD,EAAK3F,QAAQuC,OAAO+C,GAYhC,OAVEK,EAAK3F,QAAQuC,OAAOa,GAAaV,EAAWU,KAG5C+F,EAAQ9J,KAAK2I,IACXrC,EAAK3F,QAAQuC,OAAO+C,GACpB5C,EAAWU,IACI,UAAdA,EAAwBuC,EAAK3F,QAAQuC,OAAO7C,MAAQiG,EAAK3F,QAAQuC,OAAO9C,WAI7ExD,EAAA,IAAUqJ,GAAW6D,EAAKlN,IAgB9B,MA5Cc,CAAC,OAAQ,QAAS,MAAO,UAkCjC0K,QAAQ,SAAAvD,GACZxD,GAC2B,IADpB,CAAC,OAAQ,OACbrC,QAAQ6F,GACP,UACA,YAEJuC,EAAK3F,QAAQuC,OAAMpI,EAAA,GAAQwL,EAAK3F,QAAQuC,OAAW0G,EAAMrJ,GAAMwD,MAI1DuC,ECvET,SAAA0D,EAAsB1D,GACpB,QAAMvC,EAAYuC,EAAKvC,UACjBkG,EAAgBlG,EAAUE,MAAM,KAAK,GACrCiG,EAAiBnG,EAAUE,MAAM,KAAK,GAE5C,GAAIiG,EAAgB,CAClB,IAAAtN,EAAA0J,EAAA3F,QAAQnE,EAAAI,EAAAJ,KAAM0G,EAAAtG,EAAAsG,OACR8E,GAA2D,IAA9C,CAAC,SAAU,OAAO9J,QAAQ+L,GACvC1J,EAAOyH,EAAa,OAAS,MAC7B7B,EAAc6B,EAAa,QAAU,SAErCmC,EAAe,CACnBtJ,MAAIuJ,EAAA,GAAIA,EAAC7J,GAAO/D,EAAK+D,GAAK6J,GAC1BxJ,OAAKyJ,EAAA,GACHA,EAAC9J,GAAO/D,EAAK+D,GAAQ/D,EAAK2J,GAAe3J,EAAK2J,OAIlDG,EAAK3F,QAAQuC,OAAMpI,EAAA,GAAQoI,EAAWiH,EAAaD,IAGrD,OAAO5D,ECjBT,IAMAgE,EAAA,gCACEA,EAAA9O,UAAAqK,SAAA,SAAS0E,EAA0BC,EAA4B7D,GAC7D,YAD6D,IAAAA,IAAAA,GAAA,GACtD/K,KAAK6O,OAAOF,EAAaC,GAAe,IAGjDF,EAAA9O,UAAAiP,OAAA,SAAOF,EAA0BC,EAA4B7D,GAC3D,YAD2D,IAAAA,IAAAA,GAAA,GACpDjB,EAAoB8E,EAAeD,IAG5CD,EAAA9O,UAAAkP,iBAAA,SACEH,EACAC,EACA3E,EACA8E,GAIA,MAFyB,CAAC/B,EAAMoB,EAAOP,EAAiB1C,GAEhC6D,OACtB,SAACC,EAAchI,GAAa,OAAAA,EAASgI,ICtB3C,SAAAC,EAAyBN,EAA4BD,EAA0B1E,GAE7E,IAAMkF,EAAiBrF,EAAoB8E,EAAeD,GAM1D,MAAO,CACL/D,SAAU,CACRtD,OAAQsH,EACRhO,KAAM+N,EACNxD,MAAO,MAETpG,QAAS,CACPuC,OAZiByC,EAAiB6E,EAAeO,EAAgBlF,GAajErJ,KAAMuO,EACNhE,MAAO,MAETiE,eAAe,EACfjH,UAfgBD,EAAqB+B,EAAUkF,EAAgBP,EAAeD,EAAa,WAAY,GAgBvGvD,eAfkD,IAA9BnB,EAAS3H,QAAQ,SDiBnC4M,CAASN,EAAeD,EAAa1E,OAnB3C,GAwBMoF,EAAkB,IAAIX,EAE5B,SAAAI,EACEH,EACAC,EACAzG,EACA4G,EACApE,GAUA2E,EAPaD,EAAgBP,iBAC3BH,EACAC,EACAzG,EACA4G,GAGiBpE,GErDrB,IAAA4E,EAAA,WAqDE,SAAAA,EAAYC,GAAZ,IAAAC,EAAAzP,mBAXmB,IAAI0P,EAAAA,qBAEAC,EAAAA,MACrBC,EAAAA,UAAUrO,OAAQ,UAClBqO,EAAAA,UAAUrO,OAAQ,UAClBsO,EAAAA,GAAG,EAAGC,EAAAA,yBACN9P,KAAK+P,gCAGoB,IAAIC,IAG7BhQ,KAAKiQ,QACFC,UAAU,WACTT,EAAKX,iBACFpD,QAAQ,SAACyE,GACRrB,EACEsB,EAAgBD,EAAgB7I,QAChC8I,EAAgBD,EAAgBjQ,SAChCiQ,EAAgBE,WAChBF,EAAgBpB,aAChBS,EAAgBc,eAAe,KAAM,kBAMjDf,EAAA3P,UAAAqK,SAAA,SAASsG,GACPvQ,KAAKwQ,mBAAmBD,GACxBvQ,KAAK+P,SAASU,QAGhBlB,EAAA3P,UAAA4Q,mBAAA,SAAmBD,GACjBvQ,KAAK8O,iBAAiB4B,IAAIN,EAAgBG,EAAQrQ,SAAUqQ,IAG9DhB,EAAA3P,UAAA+Q,sBAAA,SAAsBC,GACpB5Q,KAAK8O,iBAAiB+B,UAAOT,EAAgBQ,yBAvChDE,EAAAA,sDAxCgCC,EAAAA,sBAAjC,GAmFA,SAAAX,EAAyBlQ,GAEvB,MAAuB,iBAAZA,EACFY,SAASqL,cAAcjM,GAG5BA,aAAmB8Q,EAAAA,WACd9Q,EAAQ+Q,cAGV/Q","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * Get CSS computed property of the given element\n */\nexport function getStyleComputedProperty(element: HTMLElement, property?: string): any {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  const window = element.ownerDocument.defaultView;\n  const css = window.getComputedStyle(element, null);\n\n  return property ? css[property] : css;\n}\n","/**\n * Returns the parentNode or the host of the element\n */\nexport function getParentNode(element: any): any {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n\n  return element.parentNode || element.host;\n}\n","/**\n * Returns the scrolling parent of the given element\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { getParentNode } from './getParentNode';\n\nexport function getScrollParent(element: any): any {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n    default:\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n  const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n  if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n","export const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n","/**\n * Determines if the browser is Internet Explorer\n */\nimport { isBrowser } from './isBrowser';\n\nconst isIE11 = isBrowser && !!((window as any).MSInputMethodContext && (document as any).documentMode);\nconst isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\nexport function isIE(version?: number) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n\n  return isIE11 || isIE10;\n}\n","/**\n * Returns the offset parent of the given element\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { isIE } from './isIE';\n\nexport function getOffsetParent(element: any): any {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  let offsetParent = element.offsetParent || null;\n  // Skip hidden elements which don't have an offsetParent\n\n  let sibling: any;\n\n  while (offsetParent === noOffsetParent && element.nextElementSibling) {\n    sibling = element.nextElementSibling;\n    offsetParent = sibling.offsetParent;\n  }\n\n  const nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if (\n    ['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 &&\n    getStyleComputedProperty(offsetParent, 'position') === 'static'\n  ) {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n","/**\n * Finds the root node (document, shadowDOM root) of the given element\n */\nexport function getRoot(node: Node): any {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n","/**\n * Finds the offset parent common to the two provided nodes\n */\nimport { isOffsetContainer } from './isOffsetContainer';\nimport { getRoot } from './getRoot';\nimport { getOffsetParent } from './getOffsetParent';\n\nexport function findCommonOffsetParent(element1: HTMLElement, element2: HTMLElement): any {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  /* tslint:disable-next-line: no-bitwise */\n  const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n\n  const start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  // Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  const { commonAncestorContainer } = range;\n\n  // Both nodes are inside #document\n  if (\n    (element1 !== commonAncestorContainer &&\n      element2 !== commonAncestorContainer) ||\n    start.contains(end)\n  ) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  const element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n","import { getOffsetParent } from './getOffsetParent';\n\nexport function isOffsetContainer(element: any) {\n  const { nodeName } = element;\n  if (nodeName === 'BODY') {\n    return false;\n  }\n\n  return (\n    nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element\n  );\n}\n","/**\n * Helper to detect borders of a given element\n */\n\nexport function getBordersSize(styles: CSSStyleDeclaration, axis: string) {\n  const sideA = axis === 'x' ? 'Left' : 'Top';\n  const sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return (\n    parseFloat(styles[`border${sideA}Width`]) +\n    parseFloat(styles[`border${sideB}Width`])\n  );\n}\n","import { isIE } from './isIE';\n\nfunction getSize(axis: string, body: HTMLElement, html: HTMLElement, computedStyle: CSSStyleDeclaration) {\n  return Math.max(\n    body[`offset${axis}`],\n    body[`scroll${axis}`],\n    html[`client${axis}`],\n    html[`offset${axis}`],\n    html[`scroll${axis}`],\n    isIE(10)\n      ? (parseInt(html[`offset${axis}`], 10) +\n      parseInt(computedStyle[`margin${axis === 'Height' ? 'Top' : 'Left'}`], 10) +\n      parseInt(computedStyle[`margin${axis === 'Height' ? 'Bottom' : 'Right'}`], 10))\n    : 0\n  );\n}\n\nexport function getWindowSizes(document: Document) {\n  const body = document.body;\n  const html = document.documentElement;\n  const computedStyle = isIE(10) && getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n","/**\n * Gets the scroll value of the given element in the given side (top and left)\n */\nexport function getScroll(element: HTMLElement, side = 'top') {\n  const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  const nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    const html = element.ownerDocument.documentElement;\n    const scrollingElement = element.ownerDocument.scrollingElement || html;\n\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n","/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n */\nimport { Offsets } from '../models';\n\nexport function getClientRect(offsets: Offsets): Offsets {\n  return {\n    ...offsets,\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  };\n}\n","/**\n * Get bounding client rect of given element\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { getBordersSize } from './getBordersSize';\nimport { getWindowSizes } from './getWindowSizes';\nimport { getScroll } from './getScroll';\nimport { getClientRect } from './getClientRect';\nimport { isIE } from './isIE';\nimport { Offsets } from '../models';\n\nexport function getBoundingClientRect(element: HTMLElement): Offsets {\n  let rect: any = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      const scrollTop = getScroll(element, 'top');\n      const scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {\n    return undefined;\n  }\n\n  const result: any = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  const sizes: any = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n  const width =\n    sizes.width || element.clientWidth || result.right - result.left;\n  const height =\n    sizes.height || element.clientHeight || result.bottom - result.top;\n\n  let horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n","import { getBoundingClientRect } from './getBoundingClientRect';\nimport { getClientRect } from './getClientRect';\nimport { getScrollParent } from './getScrollParent';\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { includeScroll } from './includeScroll';\nimport { isIE as runIsIE } from './isIE';\nimport { Offsets } from '../models';\n\nexport function getOffsetRectRelativeToArbitraryNode(\n  children: HTMLElement,\n  parent: HTMLElement,\n  fixedPosition = false\n): Offsets {\n  const isIE10 = runIsIE(10);\n  const isHTML = parent.nodeName === 'HTML';\n  const childrenRect: any = getBoundingClientRect(children);\n  const parentRect: any = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n\n  const styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n\n  let offsets: Offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (\n    isIE10 && !fixedPosition\n      ? parent.contains(scrollParent)\n      : parent === scrollParent && scrollParent.nodeName !== 'BODY'\n  ) {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n","/**\n * Sum or subtract the element scroll values (left and top) from a given rect object\n */\nimport { getScroll } from './getScroll';\nimport { Offsets } from '../models';\n\nexport function includeScroll(rect: Offsets, element: HTMLElement, subtract = false) {\n  const scrollTop = getScroll(element, 'top');\n  const scrollLeft = getScroll(element, 'left');\n  const modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n\n  return rect;\n}\n","/**\n * Finds the first parent of an element that has a transformed property defined\n */\n\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { isIE } from './isIE';\n\nexport function getFixedPositionOffsetParent(element: HTMLElement): HTMLElement {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n   return document.documentElement;\n  }\n\n  let el = element.parentElement;\n\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n\n  return el || document.documentElement;\n}\n","/**\n * Computed the boundaries limits and return them\n */\nimport { getScrollParent } from './getScrollParent';\nimport { getParentNode } from './getParentNode';\nimport { findCommonOffsetParent } from './findCommonOffsetParent';\nimport { getOffsetRectRelativeToArbitraryNode } from './getOffsetRectRelativeToArbitraryNode';\nimport { getViewportOffsetRectRelativeToArtbitraryNode } from './getViewportOffsetRectRelativeToArtbitraryNode';\nimport { getWindowSizes } from './getWindowSizes';\nimport { isFixed } from './isFixed';\nimport { getFixedPositionOffsetParent } from './getFixedPositionOffsetParent';\n\nexport function getBoundaries(\n  target: HTMLElement,\n  host: HTMLElement,\n  padding = 0,\n  boundariesElement: string,\n  fixedPosition = false\n) {\n  // NOTE: 1 DOM access here\n\n  let boundaries: any = { top: 0, left: 0 };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    let boundariesNode;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(host));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = target.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = target.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets = getOffsetRectRelativeToArbitraryNode(\n      boundariesNode,\n      offsetParent,\n      fixedPosition\n    );\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      const { height, width } = getWindowSizes(target.ownerDocument);\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = Number(height) + Number(offsets.top);\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = Number(width) + Number(offsets.left);\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  boundaries.left += padding;\n  boundaries.top += padding;\n  boundaries.right -= padding;\n  boundaries.bottom -= padding;\n\n  return boundaries;\n}\n","import { getClientRect } from './getClientRect';\nimport { getOffsetRectRelativeToArbitraryNode } from './getOffsetRectRelativeToArbitraryNode';\nimport { getScroll } from './getScroll';\nimport { Offsets } from '../models';\n\nexport function getViewportOffsetRectRelativeToArtbitraryNode(element: HTMLElement, excludeScroll = false): Offsets {\n  const html = element.ownerDocument.documentElement;\n  const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  const scrollTop = !excludeScroll ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n  const offset = {\n    top: scrollTop - Number(relativeOffset.top) + Number(relativeOffset.marginTop),\n    left: scrollLeft - Number(relativeOffset.left) + Number(relativeOffset.marginLeft),\n    width,\n    height\n  };\n\n  return getClientRect(offset);\n}\n","/**\n * Check if the given element is fixed or is inside a fixed parent\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { getParentNode } from './getParentNode';\n\nexport function isFixed(element: HTMLElement): boolean {\n  const nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n\n  return isFixed(getParentNode(element));\n}\n","/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n */\nimport { getBoundaries } from './getBoundaries';\nimport { Offsets } from '../models';\n\nfunction getArea({ width, height }: { [key: string]: number }) {\n  return width * height;\n}\n\nexport function computeAutoPlacement(\n  placement: string,\n  refRect: Offsets,\n  target: HTMLElement,\n  host: HTMLElement,\n  boundariesElement: string,\n  padding = 0\n) {\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  if (placement.indexOf('auto') !== -1\n    && (placement.indexOf('left') !== -1\n    || placement.indexOf('right') !== -1\n    || placement.indexOf('top') !== -1\n    || placement.indexOf('bottom') !== -1)) {\n\n    return placement.split(' ')[1] || '';\n  }\n\n  const boundaries = getBoundaries(target, host, padding, boundariesElement);\n\n  const rects: any = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n  const sortedAreas = Object.keys(rects)\n    .map(key => ({\n      key,\n      ...rects[key],\n      area: getArea(rects[key])\n    }))\n    .sort((a, b) => b.area - a.area);\n\n  const filteredAreas = sortedAreas.filter(\n    ({ width, height }) =>\n      width >= target.clientWidth && height >= target.clientHeight\n  );\n\n  const computedPlacement: string = filteredAreas.length > 0\n    ? filteredAreas[0].key\n    : sortedAreas[0].key;\n\n  const variation = placement.split(' ')[1];\n\n  target.className = target.className.replace(/auto/g, computedPlacement);\n\n  return computedPlacement + (variation ? `-${variation}` : '');\n}\n","/**\n * Get the opposite placement of the given one\n */\nexport function getOppositePlacement(placement: string) {\n  const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n\n  return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n}\n","/**\n * Get the outer sizes of the given element (offset size + margins)\n */\nexport function getOuterSizes(element: any) {\n  const window = element.ownerDocument.defaultView;\n  const styles = window.getComputedStyle(element);\n  const x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  const y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n\n  return {\n    width: Number(element.offsetWidth) + y,\n    height: Number(element.offsetHeight) + x\n  };\n}\n","/**\n * Get offsets to the reference element\n */\nimport { findCommonOffsetParent } from './findCommonOffsetParent';\nimport { getOffsetRectRelativeToArbitraryNode } from './getOffsetRectRelativeToArbitraryNode';\nimport { getFixedPositionOffsetParent } from './getFixedPositionOffsetParent';\nimport { Offsets } from '../models';\n\nexport function getReferenceOffsets(\n  target: HTMLElement,\n  host: HTMLElement,\n  fixedPosition: boolean = null\n): Offsets {\n  const commonOffsetParent = fixedPosition\n    ? getFixedPositionOffsetParent(target)\n    : findCommonOffsetParent(target, host);\n\n  return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\n}\n","/**\n * Get offsets to the target\n */\nimport { getOppositePlacement } from './getOppositePlacement';\nimport { getOuterSizes } from './getOuterSizes';\nimport { Offsets } from '../models';\n\nexport function getTargetOffsets(\n  target: HTMLElement,\n  hostOffsets: Offsets,\n  position: string\n): Offsets {\n  const placement = position.split(' ')[0];\n\n  // Get target node sizes\n  const targetRect = getOuterSizes(target);\n\n  // Add position, width and height to our offsets object\n  const targetOffsets = {\n    width: targetRect.width,\n    height: targetRect.height\n  };\n\n  // depending by the target placement we have to compute its offsets slightly differently\n  const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  const mainSide = isHoriz ? 'top' : 'left';\n  const secondarySide = isHoriz ? 'left' : 'top';\n  const measurement = isHoriz ? 'height' : 'width';\n  const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  targetOffsets[mainSide] =\n    hostOffsets[mainSide] +\n    hostOffsets[measurement] / 2 -\n    targetRect[measurement] / 2;\n\n  targetOffsets[secondarySide] = placement === secondarySide\n    ? hostOffsets[secondarySide] - targetRect[secondaryMeasurement]\n    : hostOffsets[getOppositePlacement(secondarySide)];\n\n  return targetOffsets;\n}\n","/**\n * Set the style to the given popper\n */\nimport { Renderer2 } from '@angular/core';\n\nimport { Data } from '../models';\nimport { getOffsets, setStyles } from './index';\n\nexport function setAllStyles(data: Data, renderer?: Renderer2): void {\n  const target = data.instance.target;\n\n  const offsets = getOffsets(data);\n\n  setStyles(target, {\n    'will-change': 'transform',\n    top: '0px',\n    left: '0px',\n    transform: `translate3d(${offsets.left}px, ${offsets.top}px, 0px)`\n  }, renderer);\n\n  if (data.instance.arrow) {\n    setStyles(data.instance.arrow, data.offsets.arrow, renderer);\n  }\n\n  if (data.placementAuto) {\n    if (renderer) {\n      renderer.setAttribute(target, 'class',\n        target.className.replace(/bs-popover-auto/g, `bs-popover-${data.placement}`)\n      );\n      renderer.setAttribute(target, 'class',\n        target.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${data.placement}`)\n      );\n\n      renderer.setAttribute(target, 'class',\n        target.className.replace(/\\sauto/g, `\\s${data.placement}`)\n      );\n\n      if (target.className.match(/popover/g)) {\n        renderer.addClass(target, 'popover-auto');\n      }\n\n      if (target.className.match(/tooltip/g)) {\n        renderer.addClass(target, 'tooltip-auto');\n      }\n\n\n    } else {\n      target.className = target.className.replace(/bs-popover-auto/g, `bs-popover-${data.placement}`);\n      target.className = target.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${data.placement}`);\n      target.className = target.className.replace(/\\sauto/g, `\\s${data.placement}`);\n\n      if (target.className.match(/popover/g)) {\n        target.classList.add('popover-auto');\n      }\n\n      if (target.className.match(/tooltip/g)) {\n        target.classList.add('tooltip-auto');\n      }\n    }\n  }\n\n  if (renderer) {\n    renderer.setAttribute(target, 'class', target.className.replace(/left|right|top|bottom/g, `${data.placement}`));\n  } else {\n    target.className = target.className.replace(/left|right|top|bottom/g, `${data.placement}`);\n  }\n}\n","import { Data, Offsets } from '../models';\n\nexport function getOffsets(data: Data): Offsets {\n  return {\n    width: data.offsets.target.width,\n    height: data.offsets.target.height,\n    left: Math.floor(data.offsets.target.left),\n    top: Math.round(data.offsets.target.top),\n    bottom: Math.round(data.offsets.target.bottom),\n    right: Math.floor(data.offsets.target.right)\n  };\n}\n","/**\n * Set the style to the given popper\n */\nimport { Renderer2 } from '@angular/core';\n\nimport { isNumeric } from './isNumeric';\n\nexport function setStyles(element: HTMLElement, styles: any, renderer?: Renderer2) {\n  Object.keys(styles).forEach((prop: any) => {\n    let unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 &&\n      isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n\n    if (renderer) {\n      renderer.setStyle(element, prop, `${String(styles[prop])}${unit}`);\n\n      return;\n    }\n\n    element.style[prop] = String(styles[prop]) + unit;\n  });\n}\n","/**\n * Tells if a given input is a number\n */\nexport function isNumeric(n: any) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n","import { getClientRect, getOuterSizes, getStyleComputedProperty } from '../utils';\nimport { Data } from '../models';\n\nexport function arrow(data: Data) {\n  let targetOffsets = data.offsets.target;\n  // if arrowElement is a string, suppose it's a CSS selector\n  const arrowElement: HTMLElement | null = data.instance.target.querySelector('.arrow');\n\n  // if arrowElement is not found, don't run the modifier\n  if (!arrowElement) {\n    return data;\n  }\n\n  const isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n\n  const len = isVertical ? 'height' : 'width';\n  const sideCapitalized = isVertical ? 'Top' : 'Left';\n  const side = sideCapitalized.toLowerCase();\n  const altSide = isVertical ? 'left' : 'top';\n  const opSide = isVertical ? 'bottom' : 'right';\n  const arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  // top/left side\n  if (data.offsets.host[opSide] - arrowElementSize < targetOffsets[side]) {\n    targetOffsets[side] -=\n      targetOffsets[side] - (data.offsets.host[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (Number(data.offsets.host[side]) + Number(arrowElementSize) > targetOffsets[opSide]) {\n    targetOffsets[side] +=\n      Number(data.offsets.host[side]) + Number(arrowElementSize) - Number(targetOffsets[opSide]);\n  }\n  targetOffsets = getClientRect(targetOffsets);\n\n  // compute center of the target\n  const center = Number(data.offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2);\n\n  // Compute the sideValue using the updated target offsets\n  // take target margin in account because we don't have this info available\n  const css = getStyleComputedProperty(data.instance.target);\n\n  const targetMarginSide = parseFloat(css[`margin${sideCapitalized}`]);\n  const targetBorderSide = parseFloat(css[`border${sideCapitalized}Width`]);\n  let sideValue =\n    center - targetOffsets[side] - targetMarginSide - targetBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its target\n  sideValue = Math.max(Math.min(targetOffsets[len] - arrowElementSize, sideValue), 0);\n\n  data.offsets.arrow = {\n    [side]: Math.round(sideValue),\n    [altSide]: '' // make sure to unset any eventual altSide value from the DOM node\n  };\n\n  data.instance.arrow = arrowElement;\n\n  return data;\n}\n","import {\n  computeAutoPlacement,\n  getBoundaries, getClientRect,\n  getOppositePlacement,\n  getOppositeVariation,\n  getTargetOffsets\n} from '../utils';\n\nimport { Data } from '../models';\n\nexport function flip(data: Data): Data {\n  data.offsets.target = getClientRect(data.offsets.target);\n\n  const boundaries = getBoundaries(\n    data.instance.target,\n    data.instance.host,\n    0, // padding\n    'viewport',\n    false // positionFixed\n  );\n\n  let placement = data.placement.split(' ')[0];\n  let variation = data.placement.split(' ')[1] || '';\n\n  const adaptivePosition = variation\n    ? getOppositePlacement(placement)\n    : computeAutoPlacement('auto', data.offsets.host, data.instance.target, data.instance.host, 'viewport', 0);\n\n  const flipOrder = [placement, adaptivePosition];\n\n  /* tslint:disable-next-line: cyclomatic-complexity */\n  flipOrder.forEach((step, index) => {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split(' ')[0];\n\n    // using floor because the host offsets may contain decimals we are not going to consider here\n    const overlapsRef =\n      (placement === 'left' &&\n        Math.floor(data.offsets.target.right) > Math.floor(data.offsets.host.left)) ||\n      (placement === 'right' &&\n        Math.floor(data.offsets.target.left) < Math.floor(data.offsets.host.right)) ||\n      (placement === 'top' &&\n        Math.floor(data.offsets.target.bottom) > Math.floor(data.offsets.host.top)) ||\n      (placement === 'bottom' &&\n        Math.floor(data.offsets.target.top) < Math.floor(data.offsets.host.bottom));\n\n    const overflowsLeft = Math.floor(data.offsets.target.left) < Math.floor(boundaries.left);\n    const overflowsRight = Math.floor(data.offsets.target.right) > Math.floor(boundaries.right);\n    const overflowsTop = Math.floor(data.offsets.target.top) < Math.floor(boundaries.top);\n    const overflowsBottom = Math.floor(data.offsets.target.bottom) > Math.floor(boundaries.bottom);\n\n    const overflowsBoundaries =\n      (placement === 'left' && overflowsLeft) ||\n      (placement === 'right' && overflowsRight) ||\n      (placement === 'top' && overflowsTop) ||\n      (placement === 'bottom' && overflowsBottom);\n\n    // flip the variation if required\n    const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    const flippedVariation =\n      ((isVertical && variation === 'left' && overflowsLeft) ||\n        (isVertical && variation === 'right' && overflowsRight) ||\n        (!isVertical && variation === 'left' && overflowsTop) ||\n        (!isVertical && variation === 'right' && overflowsBottom));\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? ` ${variation}` : '');\n\n      data.offsets.target = {\n        ...data.offsets.target,\n        ...getTargetOffsets(\n          data.instance.target,\n          data.offsets.host,\n          data.placement\n        )\n      };\n    }\n  });\n\n  return data;\n}\n","/**\n * Get the opposite placement variation of the given one\n */\nexport function getOppositeVariation(variation: string) {\n  if (variation === 'right') {\n    return 'left';\n  } else if (variation === 'left') {\n    return 'right';\n  }\n\n  return variation;\n}\n","import { getBoundaries } from '../utils';\nimport { Data } from '../models';\n\nexport function preventOverflow(data: Data) {\n\n  // NOTE: DOM access here\n  // resets the targetOffsets's position so that the document size can be calculated excluding\n  // the size of the targetOffsets element itself\n  const transformProp = 'transform';\n  const targetStyles = data.instance.target.style; // assignment to help minification\n  const { top, left, [transformProp]: transform } = targetStyles;\n  targetStyles.top = '';\n  targetStyles.left = '';\n  targetStyles[transformProp] = '';\n\n  const boundaries = getBoundaries(\n    data.instance.target,\n    data.instance.host,\n    0, // padding\n    'scrollParent',\n    false // positionFixed\n  );\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  targetStyles.top = top;\n  targetStyles.left = left;\n  targetStyles[transformProp] = transform;\n\n  const order = ['left', 'right', 'top', 'bottom'];\n\n  const check = {\n    primary(placement: string) {\n      let value = data.offsets.target[placement];\n      if (\n        data.offsets.target[placement] < boundaries[placement] &&\n        !false // options.escapeWithReference\n      ) {\n        value = Math.max(data.offsets.target[placement], boundaries[placement]);\n      }\n\n      return { [placement]: value };\n    },\n    secondary(placement: string) {\n      const mainSide = placement === 'right' ? 'left' : 'top';\n      let value = data.offsets.target[mainSide];\n      if (\n        data.offsets.target[placement] > boundaries[placement] &&\n        !false // escapeWithReference\n      ) {\n        value = Math.min(\n          data.offsets.target[mainSide],\n          boundaries[placement] -\n          (placement === 'right' ? data.offsets.target.width : data.offsets.target.height)\n        );\n      }\n\n      return { [mainSide]: value };\n    }\n  };\n\n  let side: string;\n\n  order.forEach(placement => {\n    side = ['left', 'top']\n      .indexOf(placement) !== -1\n      ? 'primary'\n      : 'secondary';\n\n    data.offsets.target = { ...data.offsets.target, ...check[side](placement) };\n\n  });\n\n  return data;\n}\n","import { Data } from '../models';\n\nexport function shift(data: Data): Data {\n  const placement = data.placement;\n  const basePlacement = placement.split(' ')[0];\n  const shiftvariation = placement.split(' ')[1];\n\n  if (shiftvariation) {\n    const { host, target } = data.offsets;\n    const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    const side = isVertical ? 'left' : 'top';\n    const measurement = isVertical ? 'width' : 'height';\n\n    const shiftOffsets = {\n      left: { [side]: host[side] },\n      right: {\n        [side]: host[side] + host[measurement] - host[measurement]\n      }\n    };\n\n    data.offsets.target = { ...target, ...shiftOffsets[shiftvariation] };\n  }\n\n  return data;\n}\n","/**\n * @copyright Valor Software\n * @copyright Federico Zivolo and contributors\n */\nimport { Renderer2 } from '@angular/core';\n\nimport { getReferenceOffsets, setAllStyles } from './utils';\n\nimport { arrow, flip, preventOverflow, shift, initData } from './modifiers';\nimport { Data, Offsets } from './models';\n\n\nexport class Positioning {\n  position(hostElement: HTMLElement, targetElement: HTMLElement, round = true): Offsets {\n    return this.offset(hostElement, targetElement, false);\n  }\n\n  offset(hostElement: HTMLElement, targetElement: HTMLElement, round = true): Offsets {\n    return getReferenceOffsets(targetElement, hostElement);\n  }\n\n  positionElements(\n    hostElement: HTMLElement,\n    targetElement: HTMLElement,\n    position: string,\n    appendToBody?: boolean\n  ): Data {\n    const chainOfModifiers = [flip, shift, preventOverflow, arrow];\n\n    return chainOfModifiers.reduce(\n      (modifiedData, modifier) => modifier(modifiedData),\n      initData(targetElement, hostElement, position)\n    );\n  }\n}\n\nconst positionService = new Positioning();\n\nexport function positionElements(\n  hostElement: HTMLElement,\n  targetElement: HTMLElement,\n  placement: string,\n  appendToBody?: boolean,\n  renderer?: Renderer2\n): void {\n\n  const data = positionService.positionElements(\n    hostElement,\n    targetElement,\n    placement,\n    appendToBody\n  );\n\n  setAllStyles(data, renderer);\n}\n","import {\n  computeAutoPlacement,\n  getReferenceOffsets,\n  getTargetOffsets\n} from '../utils';\n\nimport { Data } from '../models';\n\nexport function initData(targetElement: HTMLElement, hostElement: HTMLElement, position: string): Data {\n\n  const hostElPosition = getReferenceOffsets(targetElement, hostElement);\n  const targetOffset = getTargetOffsets(targetElement, hostElPosition, position);\n\n  const placement = computeAutoPlacement(position, hostElPosition, targetElement, hostElement, 'viewport', 0);\n  const placementAuto = position.indexOf('auto') !== -1;\n\n  return {\n    instance: {\n      target: targetElement,\n      host: hostElement,\n      arrow: null\n    },\n    offsets: {\n      target: targetOffset,\n      host: hostElPosition,\n      arrow: null\n    },\n    positionFixed: false,\n    placement,\n    placementAuto\n  };\n}\n","import { Injectable, ElementRef, RendererFactory2 } from '@angular/core';\n\nimport { positionElements } from './ng-positioning';\nimport { fromEvent, merge, of, animationFrameScheduler, Subject } from 'rxjs';\n\n\nexport interface PositioningOptions {\n  /** The DOM element, ElementRef, or a selector string of an element which will be moved */\n  element?: HTMLElement | ElementRef | string;\n\n  /** The DOM element, ElementRef, or a selector string of an element which the element will be attached to  */\n  target?: HTMLElement | ElementRef | string;\n\n  /**\n   * A string of the form 'vert-attachment horiz-attachment' or 'placement'\n   * - placement can be \"top\", \"bottom\", \"left\", \"right\"\n   * not yet supported:\n   * - vert-attachment can be any of 'top', 'middle', 'bottom'\n   * - horiz-attachment can be any of 'left', 'center', 'right'\n   */\n  attachment?: string;\n\n  /** A string similar to `attachment`. The one difference is that, if it's not provided,\n   * `targetAttachment` will assume the mirror image of `attachment`.\n   */\n  targetAttachment?: string;\n\n  /** A string of the form 'vert-offset horiz-offset'\n   * - vert-offset and horiz-offset can be of the form \"20px\" or \"55%\"\n   */\n  offset?: string;\n\n  /** A string similar to `offset`, but referring to the offset of the target */\n  targetOffset?: string;\n\n  /** If true component will be attached to body */\n  appendToBody?: boolean;\n}\n\n\n@Injectable()\nexport class PositioningService {\n  private update$$ = new Subject<null>();\n\n  private events$: any = merge(\n    fromEvent(window, 'scroll'),\n    fromEvent(window, 'resize'),\n    of(0, animationFrameScheduler),\n    this.update$$\n  );\n\n  private positionElements = new Map();\n\n  constructor(rendererFactory: RendererFactory2) {\n    this.events$\n      .subscribe(() => {\n        this.positionElements\n          .forEach((positionElement: PositioningOptions) => {\n            positionElements(\n              _getHtmlElement(positionElement.target),\n              _getHtmlElement(positionElement.element),\n              positionElement.attachment,\n              positionElement.appendToBody,\n              rendererFactory.createRenderer(null, null)\n            );\n          });\n      });\n  }\n\n  position(options: PositioningOptions): void {\n    this.addPositionElement(options);\n    this.update$$.next();\n  }\n\n  addPositionElement(options: PositioningOptions): void {\n    this.positionElements.set(_getHtmlElement(options.element), options);\n  }\n\n  deletePositionElement(elRef: ElementRef): void {\n    this.positionElements.delete(_getHtmlElement(elRef));\n  }\n}\n\nfunction _getHtmlElement(element: HTMLElement | ElementRef | string): HTMLElement {\n  // it means that we got a selector\n  if (typeof element === 'string') {\n    return document.querySelector(element);\n  }\n\n  if (element instanceof ElementRef) {\n    return element.nativeElement;\n  }\n\n  return element;\n}\n"]}