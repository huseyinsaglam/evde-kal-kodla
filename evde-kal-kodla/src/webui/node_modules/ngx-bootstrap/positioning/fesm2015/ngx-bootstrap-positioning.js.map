{"version":3,"file":"ngx-bootstrap-positioning.js.map","sources":["ng://ngx-bootstrap/positioning/utils/getStyleComputedProperty.ts","ng://ngx-bootstrap/positioning/utils/getParentNode.ts","ng://ngx-bootstrap/positioning/utils/getScrollParent.ts","ng://ngx-bootstrap/positioning/utils/isBrowser.ts","ng://ngx-bootstrap/positioning/utils/isIE.ts","ng://ngx-bootstrap/positioning/utils/getOffsetParent.ts","ng://ngx-bootstrap/positioning/utils/isOffsetContainer.ts","ng://ngx-bootstrap/positioning/utils/getRoot.ts","ng://ngx-bootstrap/positioning/utils/findCommonOffsetParent.ts","ng://ngx-bootstrap/positioning/utils/getBordersSize.ts","ng://ngx-bootstrap/positioning/utils/getWindowSizes.ts","ng://ngx-bootstrap/positioning/utils/getScroll.ts","ng://ngx-bootstrap/positioning/utils/getClientRect.ts","ng://ngx-bootstrap/positioning/utils/getBoundingClientRect.ts","ng://ngx-bootstrap/positioning/utils/includeScroll.ts","ng://ngx-bootstrap/positioning/utils/getOffsetRectRelativeToArbitraryNode.ts","ng://ngx-bootstrap/positioning/utils/getViewportOffsetRectRelativeToArtbitraryNode.ts","ng://ngx-bootstrap/positioning/utils/isFixed.ts","ng://ngx-bootstrap/positioning/utils/getFixedPositionOffsetParent.ts","ng://ngx-bootstrap/positioning/utils/getBoundaries.ts","ng://ngx-bootstrap/positioning/utils/computeAutoPlacement.ts","ng://ngx-bootstrap/positioning/utils/getOffsets.ts","ng://ngx-bootstrap/positioning/utils/getOppositePlacement.ts","ng://ngx-bootstrap/positioning/utils/getOppositeVariation.ts","ng://ngx-bootstrap/positioning/utils/getOuterSizes.ts","ng://ngx-bootstrap/positioning/utils/getReferenceOffsets.ts","ng://ngx-bootstrap/positioning/utils/getTargetOffsets.ts","ng://ngx-bootstrap/positioning/utils/isNumeric.ts","ng://ngx-bootstrap/positioning/utils/setAllStyles.ts","ng://ngx-bootstrap/positioning/utils/setStyles.ts","ng://ngx-bootstrap/positioning/modifiers/arrow.ts","ng://ngx-bootstrap/positioning/modifiers/flip.ts","ng://ngx-bootstrap/positioning/modifiers/initData.ts","ng://ngx-bootstrap/positioning/modifiers/preventOverflow.ts","ng://ngx-bootstrap/positioning/modifiers/shift.ts","ng://ngx-bootstrap/positioning/ng-positioning.ts","ng://ngx-bootstrap/positioning/positioning.service.ts"],"sourcesContent":["/**\n * Get CSS computed property of the given element\n */\nexport function getStyleComputedProperty(element: HTMLElement, property?: string): any {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  const window = element.ownerDocument.defaultView;\n  const css = window.getComputedStyle(element, null);\n\n  return property ? css[property] : css;\n}\n","/**\n * Returns the parentNode or the host of the element\n */\nexport function getParentNode(element: any): any {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n\n  return element.parentNode || element.host;\n}\n","/**\n * Returns the scrolling parent of the given element\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { getParentNode } from './getParentNode';\n\nexport function getScrollParent(element: any): any {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n    default:\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n  const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n  if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n","export const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n","/**\n * Determines if the browser is Internet Explorer\n */\nimport { isBrowser } from './isBrowser';\n\nconst isIE11 = isBrowser && !!((window as any).MSInputMethodContext && (document as any).documentMode);\nconst isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\nexport function isIE(version?: number) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n\n  return isIE11 || isIE10;\n}\n","/**\n * Returns the offset parent of the given element\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { isIE } from './isIE';\n\nexport function getOffsetParent(element: any): any {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  let offsetParent = element.offsetParent || null;\n  // Skip hidden elements which don't have an offsetParent\n\n  let sibling: any;\n\n  while (offsetParent === noOffsetParent && element.nextElementSibling) {\n    sibling = element.nextElementSibling;\n    offsetParent = sibling.offsetParent;\n  }\n\n  const nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if (\n    ['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 &&\n    getStyleComputedProperty(offsetParent, 'position') === 'static'\n  ) {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n","import { getOffsetParent } from './getOffsetParent';\n\nexport function isOffsetContainer(element: any) {\n  const { nodeName } = element;\n  if (nodeName === 'BODY') {\n    return false;\n  }\n\n  return (\n    nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element\n  );\n}\n","/**\n * Finds the root node (document, shadowDOM root) of the given element\n */\nexport function getRoot(node: Node): any {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n","/**\n * Finds the offset parent common to the two provided nodes\n */\nimport { isOffsetContainer } from './isOffsetContainer';\nimport { getRoot } from './getRoot';\nimport { getOffsetParent } from './getOffsetParent';\n\nexport function findCommonOffsetParent(element1: HTMLElement, element2: HTMLElement): any {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  /* tslint:disable-next-line: no-bitwise */\n  const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n\n  const start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  // Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  const { commonAncestorContainer } = range;\n\n  // Both nodes are inside #document\n  if (\n    (element1 !== commonAncestorContainer &&\n      element2 !== commonAncestorContainer) ||\n    start.contains(end)\n  ) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  const element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n","/**\n * Helper to detect borders of a given element\n */\n\nexport function getBordersSize(styles: CSSStyleDeclaration, axis: string) {\n  const sideA = axis === 'x' ? 'Left' : 'Top';\n  const sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return (\n    parseFloat(styles[`border${sideA}Width`]) +\n    parseFloat(styles[`border${sideB}Width`])\n  );\n}\n","import { isIE } from './isIE';\n\nfunction getSize(axis: string, body: HTMLElement, html: HTMLElement, computedStyle: CSSStyleDeclaration) {\n  return Math.max(\n    body[`offset${axis}`],\n    body[`scroll${axis}`],\n    html[`client${axis}`],\n    html[`offset${axis}`],\n    html[`scroll${axis}`],\n    isIE(10)\n      ? (parseInt(html[`offset${axis}`], 10) +\n      parseInt(computedStyle[`margin${axis === 'Height' ? 'Top' : 'Left'}`], 10) +\n      parseInt(computedStyle[`margin${axis === 'Height' ? 'Bottom' : 'Right'}`], 10))\n    : 0\n  );\n}\n\nexport function getWindowSizes(document: Document) {\n  const body = document.body;\n  const html = document.documentElement;\n  const computedStyle = isIE(10) && getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n","/**\n * Gets the scroll value of the given element in the given side (top and left)\n */\nexport function getScroll(element: HTMLElement, side = 'top') {\n  const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  const nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    const html = element.ownerDocument.documentElement;\n    const scrollingElement = element.ownerDocument.scrollingElement || html;\n\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n","/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n */\nimport { Offsets } from '../models';\n\nexport function getClientRect(offsets: Offsets): Offsets {\n  return {\n    ...offsets,\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  };\n}\n","/**\n * Get bounding client rect of given element\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { getBordersSize } from './getBordersSize';\nimport { getWindowSizes } from './getWindowSizes';\nimport { getScroll } from './getScroll';\nimport { getClientRect } from './getClientRect';\nimport { isIE } from './isIE';\nimport { Offsets } from '../models';\n\nexport function getBoundingClientRect(element: HTMLElement): Offsets {\n  let rect: any = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      const scrollTop = getScroll(element, 'top');\n      const scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {\n    return undefined;\n  }\n\n  const result: any = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  const sizes: any = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n  const width =\n    sizes.width || element.clientWidth || result.right - result.left;\n  const height =\n    sizes.height || element.clientHeight || result.bottom - result.top;\n\n  let horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n","/**\n * Sum or subtract the element scroll values (left and top) from a given rect object\n */\nimport { getScroll } from './getScroll';\nimport { Offsets } from '../models';\n\nexport function includeScroll(rect: Offsets, element: HTMLElement, subtract = false) {\n  const scrollTop = getScroll(element, 'top');\n  const scrollLeft = getScroll(element, 'left');\n  const modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n\n  return rect;\n}\n","import { getBoundingClientRect } from './getBoundingClientRect';\nimport { getClientRect } from './getClientRect';\nimport { getScrollParent } from './getScrollParent';\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { includeScroll } from './includeScroll';\nimport { isIE as runIsIE } from './isIE';\nimport { Offsets } from '../models';\n\nexport function getOffsetRectRelativeToArbitraryNode(\n  children: HTMLElement,\n  parent: HTMLElement,\n  fixedPosition = false\n): Offsets {\n  const isIE10 = runIsIE(10);\n  const isHTML = parent.nodeName === 'HTML';\n  const childrenRect: any = getBoundingClientRect(children);\n  const parentRect: any = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n\n  const styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n\n  let offsets: Offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (\n    isIE10 && !fixedPosition\n      ? parent.contains(scrollParent)\n      : parent === scrollParent && scrollParent.nodeName !== 'BODY'\n  ) {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n","import { getClientRect } from './getClientRect';\nimport { getOffsetRectRelativeToArbitraryNode } from './getOffsetRectRelativeToArbitraryNode';\nimport { getScroll } from './getScroll';\nimport { Offsets } from '../models';\n\nexport function getViewportOffsetRectRelativeToArtbitraryNode(element: HTMLElement, excludeScroll = false): Offsets {\n  const html = element.ownerDocument.documentElement;\n  const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  const scrollTop = !excludeScroll ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n  const offset = {\n    top: scrollTop - Number(relativeOffset.top) + Number(relativeOffset.marginTop),\n    left: scrollLeft - Number(relativeOffset.left) + Number(relativeOffset.marginLeft),\n    width,\n    height\n  };\n\n  return getClientRect(offset);\n}\n","/**\n * Check if the given element is fixed or is inside a fixed parent\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { getParentNode } from './getParentNode';\n\nexport function isFixed(element: HTMLElement): boolean {\n  const nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n\n  return isFixed(getParentNode(element));\n}\n","/**\n * Finds the first parent of an element that has a transformed property defined\n */\n\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { isIE } from './isIE';\n\nexport function getFixedPositionOffsetParent(element: HTMLElement): HTMLElement {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n   return document.documentElement;\n  }\n\n  let el = element.parentElement;\n\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n\n  return el || document.documentElement;\n}\n","/**\n * Computed the boundaries limits and return them\n */\nimport { getScrollParent } from './getScrollParent';\nimport { getParentNode } from './getParentNode';\nimport { findCommonOffsetParent } from './findCommonOffsetParent';\nimport { getOffsetRectRelativeToArbitraryNode } from './getOffsetRectRelativeToArbitraryNode';\nimport { getViewportOffsetRectRelativeToArtbitraryNode } from './getViewportOffsetRectRelativeToArtbitraryNode';\nimport { getWindowSizes } from './getWindowSizes';\nimport { isFixed } from './isFixed';\nimport { getFixedPositionOffsetParent } from './getFixedPositionOffsetParent';\n\nexport function getBoundaries(\n  target: HTMLElement,\n  host: HTMLElement,\n  padding = 0,\n  boundariesElement: string,\n  fixedPosition = false\n) {\n  // NOTE: 1 DOM access here\n\n  let boundaries: any = { top: 0, left: 0 };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    let boundariesNode;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(host));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = target.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = target.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets = getOffsetRectRelativeToArbitraryNode(\n      boundariesNode,\n      offsetParent,\n      fixedPosition\n    );\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      const { height, width } = getWindowSizes(target.ownerDocument);\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = Number(height) + Number(offsets.top);\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = Number(width) + Number(offsets.left);\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  boundaries.left += padding;\n  boundaries.top += padding;\n  boundaries.right -= padding;\n  boundaries.bottom -= padding;\n\n  return boundaries;\n}\n","/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n */\nimport { getBoundaries } from './getBoundaries';\nimport { Offsets } from '../models';\n\nfunction getArea({ width, height }: { [key: string]: number }) {\n  return width * height;\n}\n\nexport function computeAutoPlacement(\n  placement: string,\n  refRect: Offsets,\n  target: HTMLElement,\n  host: HTMLElement,\n  boundariesElement: string,\n  padding = 0\n) {\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  if (placement.indexOf('auto') !== -1\n    && (placement.indexOf('left') !== -1\n    || placement.indexOf('right') !== -1\n    || placement.indexOf('top') !== -1\n    || placement.indexOf('bottom') !== -1)) {\n\n    return placement.split(' ')[1] || '';\n  }\n\n  const boundaries = getBoundaries(target, host, padding, boundariesElement);\n\n  const rects: any = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n  const sortedAreas = Object.keys(rects)\n    .map(key => ({\n      key,\n      ...rects[key],\n      area: getArea(rects[key])\n    }))\n    .sort((a, b) => b.area - a.area);\n\n  const filteredAreas = sortedAreas.filter(\n    ({ width, height }) =>\n      width >= target.clientWidth && height >= target.clientHeight\n  );\n\n  const computedPlacement: string = filteredAreas.length > 0\n    ? filteredAreas[0].key\n    : sortedAreas[0].key;\n\n  const variation = placement.split(' ')[1];\n\n  target.className = target.className.replace(/auto/g, computedPlacement);\n\n  return computedPlacement + (variation ? `-${variation}` : '');\n}\n","import { Data, Offsets } from '../models';\n\nexport function getOffsets(data: Data): Offsets {\n  return {\n    width: data.offsets.target.width,\n    height: data.offsets.target.height,\n    left: Math.floor(data.offsets.target.left),\n    top: Math.round(data.offsets.target.top),\n    bottom: Math.round(data.offsets.target.bottom),\n    right: Math.floor(data.offsets.target.right)\n  };\n}\n","/**\n * Get the opposite placement of the given one\n */\nexport function getOppositePlacement(placement: string) {\n  const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n\n  return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n}\n","/**\n * Get the opposite placement variation of the given one\n */\nexport function getOppositeVariation(variation: string) {\n  if (variation === 'right') {\n    return 'left';\n  } else if (variation === 'left') {\n    return 'right';\n  }\n\n  return variation;\n}\n","/**\n * Get the outer sizes of the given element (offset size + margins)\n */\nexport function getOuterSizes(element: any) {\n  const window = element.ownerDocument.defaultView;\n  const styles = window.getComputedStyle(element);\n  const x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  const y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n\n  return {\n    width: Number(element.offsetWidth) + y,\n    height: Number(element.offsetHeight) + x\n  };\n}\n","/**\n * Get offsets to the reference element\n */\nimport { findCommonOffsetParent } from './findCommonOffsetParent';\nimport { getOffsetRectRelativeToArbitraryNode } from './getOffsetRectRelativeToArbitraryNode';\nimport { getFixedPositionOffsetParent } from './getFixedPositionOffsetParent';\nimport { Offsets } from '../models';\n\nexport function getReferenceOffsets(\n  target: HTMLElement,\n  host: HTMLElement,\n  fixedPosition: boolean = null\n): Offsets {\n  const commonOffsetParent = fixedPosition\n    ? getFixedPositionOffsetParent(target)\n    : findCommonOffsetParent(target, host);\n\n  return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\n}\n","/**\n * Get offsets to the target\n */\nimport { getOppositePlacement } from './getOppositePlacement';\nimport { getOuterSizes } from './getOuterSizes';\nimport { Offsets } from '../models';\n\nexport function getTargetOffsets(\n  target: HTMLElement,\n  hostOffsets: Offsets,\n  position: string\n): Offsets {\n  const placement = position.split(' ')[0];\n\n  // Get target node sizes\n  const targetRect = getOuterSizes(target);\n\n  // Add position, width and height to our offsets object\n  const targetOffsets = {\n    width: targetRect.width,\n    height: targetRect.height\n  };\n\n  // depending by the target placement we have to compute its offsets slightly differently\n  const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  const mainSide = isHoriz ? 'top' : 'left';\n  const secondarySide = isHoriz ? 'left' : 'top';\n  const measurement = isHoriz ? 'height' : 'width';\n  const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  targetOffsets[mainSide] =\n    hostOffsets[mainSide] +\n    hostOffsets[measurement] / 2 -\n    targetRect[measurement] / 2;\n\n  targetOffsets[secondarySide] = placement === secondarySide\n    ? hostOffsets[secondarySide] - targetRect[secondaryMeasurement]\n    : hostOffsets[getOppositePlacement(secondarySide)];\n\n  return targetOffsets;\n}\n","/**\n * Tells if a given input is a number\n */\nexport function isNumeric(n: any) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n","/**\n * Set the style to the given popper\n */\nimport { Renderer2 } from '@angular/core';\n\nimport { Data } from '../models';\nimport { getOffsets, setStyles } from './index';\n\nexport function setAllStyles(data: Data, renderer?: Renderer2): void {\n  const target = data.instance.target;\n\n  const offsets = getOffsets(data);\n\n  setStyles(target, {\n    'will-change': 'transform',\n    top: '0px',\n    left: '0px',\n    transform: `translate3d(${offsets.left}px, ${offsets.top}px, 0px)`\n  }, renderer);\n\n  if (data.instance.arrow) {\n    setStyles(data.instance.arrow, data.offsets.arrow, renderer);\n  }\n\n  if (data.placementAuto) {\n    if (renderer) {\n      renderer.setAttribute(target, 'class',\n        target.className.replace(/bs-popover-auto/g, `bs-popover-${data.placement}`)\n      );\n      renderer.setAttribute(target, 'class',\n        target.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${data.placement}`)\n      );\n\n      renderer.setAttribute(target, 'class',\n        target.className.replace(/\\sauto/g, `\\s${data.placement}`)\n      );\n\n      if (target.className.match(/popover/g)) {\n        renderer.addClass(target, 'popover-auto');\n      }\n\n      if (target.className.match(/tooltip/g)) {\n        renderer.addClass(target, 'tooltip-auto');\n      }\n\n\n    } else {\n      target.className = target.className.replace(/bs-popover-auto/g, `bs-popover-${data.placement}`);\n      target.className = target.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${data.placement}`);\n      target.className = target.className.replace(/\\sauto/g, `\\s${data.placement}`);\n\n      if (target.className.match(/popover/g)) {\n        target.classList.add('popover-auto');\n      }\n\n      if (target.className.match(/tooltip/g)) {\n        target.classList.add('tooltip-auto');\n      }\n    }\n  }\n\n  if (renderer) {\n    renderer.setAttribute(target, 'class', target.className.replace(/left|right|top|bottom/g, `${data.placement}`));\n  } else {\n    target.className = target.className.replace(/left|right|top|bottom/g, `${data.placement}`);\n  }\n}\n","/**\n * Set the style to the given popper\n */\nimport { Renderer2 } from '@angular/core';\n\nimport { isNumeric } from './isNumeric';\n\nexport function setStyles(element: HTMLElement, styles: any, renderer?: Renderer2) {\n  Object.keys(styles).forEach((prop: any) => {\n    let unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 &&\n      isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n\n    if (renderer) {\n      renderer.setStyle(element, prop, `${String(styles[prop])}${unit}`);\n\n      return;\n    }\n\n    element.style[prop] = String(styles[prop]) + unit;\n  });\n}\n","import { getClientRect, getOuterSizes, getStyleComputedProperty } from '../utils';\nimport { Data } from '../models';\n\nexport function arrow(data: Data) {\n  let targetOffsets = data.offsets.target;\n  // if arrowElement is a string, suppose it's a CSS selector\n  const arrowElement: HTMLElement | null = data.instance.target.querySelector('.arrow');\n\n  // if arrowElement is not found, don't run the modifier\n  if (!arrowElement) {\n    return data;\n  }\n\n  const isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n\n  const len = isVertical ? 'height' : 'width';\n  const sideCapitalized = isVertical ? 'Top' : 'Left';\n  const side = sideCapitalized.toLowerCase();\n  const altSide = isVertical ? 'left' : 'top';\n  const opSide = isVertical ? 'bottom' : 'right';\n  const arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  // top/left side\n  if (data.offsets.host[opSide] - arrowElementSize < targetOffsets[side]) {\n    targetOffsets[side] -=\n      targetOffsets[side] - (data.offsets.host[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (Number(data.offsets.host[side]) + Number(arrowElementSize) > targetOffsets[opSide]) {\n    targetOffsets[side] +=\n      Number(data.offsets.host[side]) + Number(arrowElementSize) - Number(targetOffsets[opSide]);\n  }\n  targetOffsets = getClientRect(targetOffsets);\n\n  // compute center of the target\n  const center = Number(data.offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2);\n\n  // Compute the sideValue using the updated target offsets\n  // take target margin in account because we don't have this info available\n  const css = getStyleComputedProperty(data.instance.target);\n\n  const targetMarginSide = parseFloat(css[`margin${sideCapitalized}`]);\n  const targetBorderSide = parseFloat(css[`border${sideCapitalized}Width`]);\n  let sideValue =\n    center - targetOffsets[side] - targetMarginSide - targetBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its target\n  sideValue = Math.max(Math.min(targetOffsets[len] - arrowElementSize, sideValue), 0);\n\n  data.offsets.arrow = {\n    [side]: Math.round(sideValue),\n    [altSide]: '' // make sure to unset any eventual altSide value from the DOM node\n  };\n\n  data.instance.arrow = arrowElement;\n\n  return data;\n}\n","import {\n  computeAutoPlacement,\n  getBoundaries, getClientRect,\n  getOppositePlacement,\n  getOppositeVariation,\n  getTargetOffsets\n} from '../utils';\n\nimport { Data } from '../models';\n\nexport function flip(data: Data): Data {\n  data.offsets.target = getClientRect(data.offsets.target);\n\n  const boundaries = getBoundaries(\n    data.instance.target,\n    data.instance.host,\n    0, // padding\n    'viewport',\n    false // positionFixed\n  );\n\n  let placement = data.placement.split(' ')[0];\n  let variation = data.placement.split(' ')[1] || '';\n\n  const adaptivePosition = variation\n    ? getOppositePlacement(placement)\n    : computeAutoPlacement('auto', data.offsets.host, data.instance.target, data.instance.host, 'viewport', 0);\n\n  const flipOrder = [placement, adaptivePosition];\n\n  /* tslint:disable-next-line: cyclomatic-complexity */\n  flipOrder.forEach((step, index) => {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split(' ')[0];\n\n    // using floor because the host offsets may contain decimals we are not going to consider here\n    const overlapsRef =\n      (placement === 'left' &&\n        Math.floor(data.offsets.target.right) > Math.floor(data.offsets.host.left)) ||\n      (placement === 'right' &&\n        Math.floor(data.offsets.target.left) < Math.floor(data.offsets.host.right)) ||\n      (placement === 'top' &&\n        Math.floor(data.offsets.target.bottom) > Math.floor(data.offsets.host.top)) ||\n      (placement === 'bottom' &&\n        Math.floor(data.offsets.target.top) < Math.floor(data.offsets.host.bottom));\n\n    const overflowsLeft = Math.floor(data.offsets.target.left) < Math.floor(boundaries.left);\n    const overflowsRight = Math.floor(data.offsets.target.right) > Math.floor(boundaries.right);\n    const overflowsTop = Math.floor(data.offsets.target.top) < Math.floor(boundaries.top);\n    const overflowsBottom = Math.floor(data.offsets.target.bottom) > Math.floor(boundaries.bottom);\n\n    const overflowsBoundaries =\n      (placement === 'left' && overflowsLeft) ||\n      (placement === 'right' && overflowsRight) ||\n      (placement === 'top' && overflowsTop) ||\n      (placement === 'bottom' && overflowsBottom);\n\n    // flip the variation if required\n    const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    const flippedVariation =\n      ((isVertical && variation === 'left' && overflowsLeft) ||\n        (isVertical && variation === 'right' && overflowsRight) ||\n        (!isVertical && variation === 'left' && overflowsTop) ||\n        (!isVertical && variation === 'right' && overflowsBottom));\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? ` ${variation}` : '');\n\n      data.offsets.target = {\n        ...data.offsets.target,\n        ...getTargetOffsets(\n          data.instance.target,\n          data.offsets.host,\n          data.placement\n        )\n      };\n    }\n  });\n\n  return data;\n}\n","import {\n  computeAutoPlacement,\n  getReferenceOffsets,\n  getTargetOffsets\n} from '../utils';\n\nimport { Data } from '../models';\n\nexport function initData(targetElement: HTMLElement, hostElement: HTMLElement, position: string): Data {\n\n  const hostElPosition = getReferenceOffsets(targetElement, hostElement);\n  const targetOffset = getTargetOffsets(targetElement, hostElPosition, position);\n\n  const placement = computeAutoPlacement(position, hostElPosition, targetElement, hostElement, 'viewport', 0);\n  const placementAuto = position.indexOf('auto') !== -1;\n\n  return {\n    instance: {\n      target: targetElement,\n      host: hostElement,\n      arrow: null\n    },\n    offsets: {\n      target: targetOffset,\n      host: hostElPosition,\n      arrow: null\n    },\n    positionFixed: false,\n    placement,\n    placementAuto\n  };\n}\n","import { getBoundaries } from '../utils';\nimport { Data } from '../models';\n\nexport function preventOverflow(data: Data) {\n\n  // NOTE: DOM access here\n  // resets the targetOffsets's position so that the document size can be calculated excluding\n  // the size of the targetOffsets element itself\n  const transformProp = 'transform';\n  const targetStyles = data.instance.target.style; // assignment to help minification\n  const { top, left, [transformProp]: transform } = targetStyles;\n  targetStyles.top = '';\n  targetStyles.left = '';\n  targetStyles[transformProp] = '';\n\n  const boundaries = getBoundaries(\n    data.instance.target,\n    data.instance.host,\n    0, // padding\n    'scrollParent',\n    false // positionFixed\n  );\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  targetStyles.top = top;\n  targetStyles.left = left;\n  targetStyles[transformProp] = transform;\n\n  const order = ['left', 'right', 'top', 'bottom'];\n\n  const check = {\n    primary(placement: string) {\n      let value = data.offsets.target[placement];\n      if (\n        data.offsets.target[placement] < boundaries[placement] &&\n        !false // options.escapeWithReference\n      ) {\n        value = Math.max(data.offsets.target[placement], boundaries[placement]);\n      }\n\n      return { [placement]: value };\n    },\n    secondary(placement: string) {\n      const mainSide = placement === 'right' ? 'left' : 'top';\n      let value = data.offsets.target[mainSide];\n      if (\n        data.offsets.target[placement] > boundaries[placement] &&\n        !false // escapeWithReference\n      ) {\n        value = Math.min(\n          data.offsets.target[mainSide],\n          boundaries[placement] -\n          (placement === 'right' ? data.offsets.target.width : data.offsets.target.height)\n        );\n      }\n\n      return { [mainSide]: value };\n    }\n  };\n\n  let side: string;\n\n  order.forEach(placement => {\n    side = ['left', 'top']\n      .indexOf(placement) !== -1\n      ? 'primary'\n      : 'secondary';\n\n    data.offsets.target = { ...data.offsets.target, ...check[side](placement) };\n\n  });\n\n  return data;\n}\n","import { Data } from '../models';\n\nexport function shift(data: Data): Data {\n  const placement = data.placement;\n  const basePlacement = placement.split(' ')[0];\n  const shiftvariation = placement.split(' ')[1];\n\n  if (shiftvariation) {\n    const { host, target } = data.offsets;\n    const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    const side = isVertical ? 'left' : 'top';\n    const measurement = isVertical ? 'width' : 'height';\n\n    const shiftOffsets = {\n      left: { [side]: host[side] },\n      right: {\n        [side]: host[side] + host[measurement] - host[measurement]\n      }\n    };\n\n    data.offsets.target = { ...target, ...shiftOffsets[shiftvariation] };\n  }\n\n  return data;\n}\n","/**\n * @copyright Valor Software\n * @copyright Federico Zivolo and contributors\n */\nimport { Renderer2 } from '@angular/core';\n\nimport { getReferenceOffsets, setAllStyles } from './utils';\n\nimport { arrow, flip, preventOverflow, shift, initData } from './modifiers';\nimport { Data, Offsets } from './models';\n\n\nexport class Positioning {\n  position(hostElement: HTMLElement, targetElement: HTMLElement, round = true): Offsets {\n    return this.offset(hostElement, targetElement, false);\n  }\n\n  offset(hostElement: HTMLElement, targetElement: HTMLElement, round = true): Offsets {\n    return getReferenceOffsets(targetElement, hostElement);\n  }\n\n  positionElements(\n    hostElement: HTMLElement,\n    targetElement: HTMLElement,\n    position: string,\n    appendToBody?: boolean\n  ): Data {\n    const chainOfModifiers = [flip, shift, preventOverflow, arrow];\n\n    return chainOfModifiers.reduce(\n      (modifiedData, modifier) => modifier(modifiedData),\n      initData(targetElement, hostElement, position)\n    );\n  }\n}\n\nconst positionService = new Positioning();\n\nexport function positionElements(\n  hostElement: HTMLElement,\n  targetElement: HTMLElement,\n  placement: string,\n  appendToBody?: boolean,\n  renderer?: Renderer2\n): void {\n\n  const data = positionService.positionElements(\n    hostElement,\n    targetElement,\n    placement,\n    appendToBody\n  );\n\n  setAllStyles(data, renderer);\n}\n","import { Injectable, ElementRef, RendererFactory2 } from '@angular/core';\n\nimport { positionElements } from './ng-positioning';\nimport { fromEvent, merge, of, animationFrameScheduler, Subject } from 'rxjs';\n\n\nexport interface PositioningOptions {\n  /** The DOM element, ElementRef, or a selector string of an element which will be moved */\n  element?: HTMLElement | ElementRef | string;\n\n  /** The DOM element, ElementRef, or a selector string of an element which the element will be attached to  */\n  target?: HTMLElement | ElementRef | string;\n\n  /**\n   * A string of the form 'vert-attachment horiz-attachment' or 'placement'\n   * - placement can be \"top\", \"bottom\", \"left\", \"right\"\n   * not yet supported:\n   * - vert-attachment can be any of 'top', 'middle', 'bottom'\n   * - horiz-attachment can be any of 'left', 'center', 'right'\n   */\n  attachment?: string;\n\n  /** A string similar to `attachment`. The one difference is that, if it's not provided,\n   * `targetAttachment` will assume the mirror image of `attachment`.\n   */\n  targetAttachment?: string;\n\n  /** A string of the form 'vert-offset horiz-offset'\n   * - vert-offset and horiz-offset can be of the form \"20px\" or \"55%\"\n   */\n  offset?: string;\n\n  /** A string similar to `offset`, but referring to the offset of the target */\n  targetOffset?: string;\n\n  /** If true component will be attached to body */\n  appendToBody?: boolean;\n}\n\n\n@Injectable()\nexport class PositioningService {\n  private update$$ = new Subject<null>();\n\n  private events$: any = merge(\n    fromEvent(window, 'scroll'),\n    fromEvent(window, 'resize'),\n    of(0, animationFrameScheduler),\n    this.update$$\n  );\n\n  private positionElements = new Map();\n\n  constructor(rendererFactory: RendererFactory2) {\n    this.events$\n      .subscribe(() => {\n        this.positionElements\n          .forEach((positionElement: PositioningOptions) => {\n            positionElements(\n              _getHtmlElement(positionElement.target),\n              _getHtmlElement(positionElement.element),\n              positionElement.attachment,\n              positionElement.appendToBody,\n              rendererFactory.createRenderer(null, null)\n            );\n          });\n      });\n  }\n\n  position(options: PositioningOptions): void {\n    this.addPositionElement(options);\n    this.update$$.next();\n  }\n\n  addPositionElement(options: PositioningOptions): void {\n    this.positionElements.set(_getHtmlElement(options.element), options);\n  }\n\n  deletePositionElement(elRef: ElementRef): void {\n    this.positionElements.delete(_getHtmlElement(elRef));\n  }\n}\n\nfunction _getHtmlElement(element: HTMLElement | ElementRef | string): HTMLElement {\n  // it means that we got a selector\n  if (typeof element === 'string') {\n    return document.querySelector(element);\n  }\n\n  if (element instanceof ElementRef) {\n    return element.nativeElement;\n  }\n\n  return element;\n}\n"],"names":["runIsIE","setAllStyles"],"mappings":"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"}
